Version 1
SubGoalCombiner SGC_AND
INITSECTION
DB_Singleton("InitData",0);

DB_DialogStatusSetter((FLAG)GLO_SetKnockdown_01f59f7d-7cea-4822-81e5-2802cd58f4b6,(FLAG)GLO_ClearKnockdown_7dcd4aac-a388-4124-963e-d85fec572d44,"KNOCKED_DOWN");
DB_DialogStatusSetter((FLAG)GLO_SetKnockdown2_cb977481-185d-4848-9999-c3f52b26dbfb,(FLAG)GLO_ClearKnockdown2_1edfd5fb-955e-4091-bd16-72a0ff14b26e,"KNOCKED_DOWN"); //Copy of previous line to be able to set knockdown on multiple speakers in one node

NOT DB_GlobalFlagReactionAfterDialog((FLAG)NULL_00000000-0000-0000-0000-000000000000,(DIALOGRESOURCE)NULL_00000000-0000-0000-0000-000000000000);

DB_GLO_WeaponSlots("Melee Main Weapon");
DB_GLO_WeaponSlots("Melee Offhand Weapon");
DB_GLO_WeaponSlots("Ranged Main Weapon");
DB_GLO_WeaponSlots("Ranged Offhand Weapon");

DB_FactionHostilityBlacklist((FACTION)Item_Neutral_376e33c4-dd15-4c46-a586-87d8b421a0c7);
DB_FactionHostilityBlacklist((FACTION)Neutral_a66b2d45-1b6c-082d-8a01-c6d975ead314);
DB_FactionHostilityBlacklist((FACTION)NeutralNPC_cfb709b3-220f-9682-bcfb-6f0d8837462e);
DB_FactionHostilityBlacklist((FACTION)Hero_a1542c81-6895-929e-4522-10ce218bb360);
DB_FactionHostilityBlacklist((FACTION)AnimalBase_a863d0cc-60b9-b450-f90d-8a4dc192ecb9);
DB_FactionHostilityBlacklist((FACTION)Animal_Bear_92bf36f9-e9ab-ab01-bfea-4890dd6e24b0);
DB_FactionHostilityBlacklist((FACTION)Animal_Beetle_862cddf3-9918-b539-70a2-f947b8a29a46);
DB_FactionHostilityBlacklist((FACTION)Animal_Boar_b0a95db6-f0be-85c1-d327-5ea230115471);
DB_FactionHostilityBlacklist((FACTION)Animal_Bull_4d888270-b18b-5a6c-45fa-96ab6124dd20);
DB_FactionHostilityBlacklist((FACTION)Animal_Cat_7c6404dc-5241-a019-f48f-d92c9da80494);
DB_FactionHostilityBlacklist((FACTION)Animal_Chicken_3e083656-3021-8a37-6d6f-fc40ebe36928);
DB_FactionHostilityBlacklist((FACTION)Animal_Condor_26d25594-0cd6-eaf5-7281-ee9cb6d104c2);
DB_FactionHostilityBlacklist((FACTION)Animal_Crab_bef56903-2989-ff87-e5e5-1609d163df38);
DB_FactionHostilityBlacklist((FACTION)Animal_Deer_65b34013-222d-c9e1-5221-75766a9850eb);
DB_FactionHostilityBlacklist((FACTION)Animal_Dog_53767d10-d78d-aeb2-fb53-a98cf0c538b3);
DB_FactionHostilityBlacklist((FACTION)Animal_Frog_75b1890d-e482-4813-7a7f-086ce01bc550);
DB_FactionHostilityBlacklist((FACTION)Animal_Owl_ac2a672b-3fde-cca9-6fb5-69a6b971089c);
DB_FactionHostilityBlacklist((FACTION)Animal_Phoenix_60190c3d-b8d7-e6a8-8215-779e4a9e6389);
DB_FactionHostilityBlacklist((FACTION)Animal_Pig_d117b2ab-a48e-abbc-5d05-79d40b1a82a6);
DB_FactionHostilityBlacklist((FACTION)Animal_Rabbit_7b692b08-b2d3-022e-cb59-d51adac81ba3);
DB_FactionHostilityBlacklist((FACTION)Animal_Rat_3a2161c9-e490-6c32-d78e-c3b44832206e);
DB_FactionHostilityBlacklist((FACTION)Animal_Salamander_7c5da2e9-12b4-7c4d-51b9-10a24b2bd1b8);
DB_FactionHostilityBlacklist((FACTION)Animal_Sheep_3d5ae1a1-9aa4-a688-2385-c452d5434dcd);
DB_FactionHostilityBlacklist((FACTION)Animal_Squirrel_f68ae56f-975d-9e42-b123-242f707f9f68);
DB_FactionHostilityBlacklist((FACTION)Animal_Tiger_5dce625d-8e52-4f5a-bc2c-0b9b656c3c6e);
DB_FactionHostilityBlacklist((FACTION)Animal_Turtle_28341024-858a-3896-03b8-f49deeba8b1e);
DB_FactionHostilityBlacklist((FACTION)Good_b37bfd4c-baed-08f4-9866-290f8bb39e62);
DB_FactionHostilityBlacklist((FACTION)Owlbear_d52f4ac8-1cd7-8c54-2a27-6132bb7cc600);

NOT DB_InRegionFlag((TRIGGER)NULL_00000000-0000-0000-0000-000000000000,(FLAG)NULL_00000000-0000-0000-0000-000000000000);

NOT DB_CharacterInRegionFlag((CHARACTER)NULL_00000000-0000-0000-0000-000000000000,(TRIGGER)NULL_00000000-0000-0000-0000-000000000000,(FLAG)NULL_00000000-0000-0000-0000-000000000000);

NOT DB_ItemInRegionFlag((ITEM)NULL_00000000-0000-0000-0000-000000000000,(TRIGGER)NULL_00000000-0000-0000-0000-000000000000,(FLAG)NULL_00000000-0000-0000-0000-000000000000);

NOT DB_GLO_ExclusiveFlag("", (FLAG)NULL_00000000-0000-0000-0000-000000000000);

NOT DB_Dialog_AddAllNearbyPlayersAtStart((DIALOGRESOURCE)NULL_00000000-0000-0000-0000-000000000000);

NOT DB_Dialog_AddAllNearbyVisiblePlayersAtStart((DIALOGRESOURCE)NULL_00000000-0000-0000-0000-000000000000);

NOT DB_Dialog_AddAllNearbyVisiblePlayersAtStart((DIALOGRESOURCE)NULL_00000000-0000-0000-0000-000000000000, 0);

NOT DB_Singleton_GUID("",NULL_00000000-0000-0000-0000-000000000000);

NOT DB_BookFlags((ITEM)NULL_00000000-0000-0000-0000-000000000000,(FLAG)NULL_00000000-0000-0000-0000-000000000000);

NOT DB_BookTemplateFlags((ITEMROOT)NULL_00000000-0000-0000-0000-000000000000, (FLAG)NULL_00000000-0000-0000-0000-000000000000);

NOT DB_AddCharactersInTriggerToDialog((DIALOGRESOURCE)NULL_00000000-0000-0000-0000-000000000000,(TRIGGER)NULL_00000000-0000-0000-0000-000000000000,0);
NOT DB_AddCharactersInTriggerToDialog((DIALOGRESOURCE)NULL_00000000-0000-0000-0000-000000000000,(TRIGGER)NULL_00000000-0000-0000-0000-000000000000,0,0);
NOT DB_AddCharactersInTriggerToDialog((DIALOGRESOURCE)NULL_00000000-0000-0000-0000-000000000000,(TRIGGER)NULL_00000000-0000-0000-0000-000000000000,0,0,0);
NOT DB_AddCharactersInTriggerToDialog((DIALOGRESOURCE)NULL_00000000-0000-0000-0000-000000000000,(TRIGGER)NULL_00000000-0000-0000-0000-000000000000,0,0,0,0);
NOT DB_AddCharactersInTriggerToDialog_IgnoreHidden((DIALOGRESOURCE)NULL_00000000-0000-0000-0000-000000000000);

NOT DB_CorpseCleanup_Area((TRIGGER)NULL_00000000-0000-0000-0000-000000000000);
NOT DB_CorpseCleanup_Ignore((CHARACTER)NULL_00000000-0000-0000-0000-000000000000);

DB_DBDebug_ReturnDBs(1,"DB_DBDebug_1Param_GUID");
DB_DBDebug_ReturnDBs(1,"DB_DBDebug_1Param_INT");
DB_DBDebug_ReturnDBs(1,"DB_DBDebug_1Param_STRING");
DB_DBDebug_ReturnDBs(2,"DB_DBDebug_2Param_GUID_GUID");
DB_DBDebug_ReturnDBs(2,"DB_DBDebug_2Param_GUID_INT");
DB_DBDebug_ReturnDBs(2,"DB_DBDebug_2Param_GUID_STRING");
DB_DBDebug_ReturnDBs(2,"DB_DBDebug_2Param_INT_GUID");
DB_DBDebug_ReturnDBs(2,"DB_DBDebug_2Param_INT_INT");
DB_DBDebug_ReturnDBs(2,"DB_DBDebug_2Param_INT_STRING");
DB_DBDebug_ReturnDBs(2,"DB_DBDebug_2Param_STRING_GUID");
DB_DBDebug_ReturnDBs(2,"DB_DBDebug_2Param_STRING_INT");
DB_DBDebug_ReturnDBs(2,"DB_DBDebug_2Param_STRING_STRING");
DB_DBDebug_ReturnDBs(3,"DB_DBDebug_3Param_INT_GUID_INT"); //DB_DialogSpeakers etc.
DB_DBDebug_ReturnDBs(3,"DB_DBDebug_3Param_GUID_GUID_INT"); //DB_ApprovalRating etc.
DB_DBDebug_ReturnDBs(4,"DB_DBDebug_4Param_GUID_INT_GUID_INT"); //DB_DialogRequestCache_SpeakerList_Players etc.

NOT DB_LevelUnreachable("_LevelName");
NOT DB_LevelUnreachable_TrackEntity((GUIDSTRING)NULL_00000000-0000-0000-0000-000000000000);
NOT DB_LevelUnreachable_LevelBlocksLevel("_CurrentLevel","_BlockedLevel");

DB_StatusGroups_UnconsciousOrEquivalent("SG_Incapacitated");
DB_StatusGroups_UnconsciousOrEquivalent("SG_Unconscious");
DB_StatusGroups_UnconsciousOrEquivalent("SG_Stunned");

PROC_QRY_DoNTimesInit();

//REGION Blocking specific charaters from selling specific items or templates
//Characters is these DBs are blocked from selling Item or Items of defined Template while the DBs are defined
//To define, add an entry to DB_CharacterBlockedFromSellingItem or DB_CharacterBlockedFromSellingTemplate
//To clear this, simply remove the entries in DB_CharacterBlockedFromSellingItem or DB_CharacterBlockedFromSellingTemplate
//Items already held by characters when the DBs are defined are immediately set to NonTradeable
// -- DB_CharacterBlockedFromSellingItem((CHARACTER)_Character, (ITEM)_Item); 
// -- DB_CharacterBlockedFromSellingTemplate((CHARACTER)_Character, (ITEMROOT)_Template); 

//Optionally, set a flag in the DB_CharacterBlockedFromSellingItem_CancelledBy which will clear the DB above once the flag is true and set any affected Items already in inventories of these characters back to Default
//If a DB is defined while the CancelledBy flag is already set, it will clear the DB and throw an assert
// -- DB_CharacterBlockedFromSellingItem_CancelledBy((CHARACTER)_Character, (ITEM)_Item, (FLAG)_Flag); 
// -- DB_CharacterBlockedFromSellingTemplate_CancelledBy((CHARACTER)_Character, (ITEMROOT)_Template, (FLAG)_Flag);

NOT DB_CharacterBlockedFromSellingItem((CHARACTER)NULL_00000000-0000-0000-0000-000000000000, (ITEM)NULL_00000000-0000-0000-0000-000000000000);
NOT DB_CharacterBlockedFromSellingTemplate((CHARACTER)NULL_00000000-0000-0000-0000-000000000000, (ITEMROOT)NULL_00000000-0000-0000-0000-000000000000);
NOT DB_CharacterBlockedFromSellingItem_CancelledBy((CHARACTER)NULL_00000000-0000-0000-0000-000000000000, (ITEM)NULL_00000000-0000-0000-0000-000000000000, (FLAG)NULL_00000000-0000-0000-0000-000000000000); //FlagType: Global
NOT DB_CharacterBlockedFromSellingTemplate_CancelledBy((CHARACTER)NULL_00000000-0000-0000-0000-000000000000, (ITEMROOT)NULL_00000000-0000-0000-0000-000000000000, (FLAG)NULL_00000000-0000-0000-0000-000000000000); //FlagType: Global
//END_REGION
KBSECTION
//REGION DebugFrameCounter
IF
TextEvent("FrameCounter")
THEN
DB_DebugFrameCounter(1);
TimerLaunch("DebugFrameCounter",0);

IF
TimerFinished("DebugFrameCounter")
AND
DB_DebugFrameCounter(_FrameCounter)
AND
IntegerSum(_FrameCounter,1,_NewFrameCounter)
THEN
NOT DB_DebugFrameCounter(_FrameCounter);
DB_DebugFrameCounter(_NewFrameCounter);
TimerLaunch("DebugFrameCounter",0);
//END_REGION

//REGION Random Database Entry
PROC
PROC_GetRandom((STRING)_InPredicate,(INTEGER)_Arity,(STRING)_OutPredicate)
AND
SysCount(_InPredicate,_Arity,_Count)
AND
_Count > 0
AND
Random(_Count,_IndexZeroBased)
AND
IntegerSum(_IndexZeroBased,1,_IndexOneBased)
AND
SysFactAtIndex(_InPredicate,_Arity,_IndexOneBased,_OutPredicate)
THEN
DB_NOOP(1);

QRY
QRY_GetRandom((STRING)_InPredicate,(INTEGER)_Arity,(STRING)_OutPredicate)
AND
SysCount(_InPredicate,_Arity,_Count)
AND
_Count > 0
AND
Random(_Count,_IndexZeroBased)
AND
IntegerSum(_IndexZeroBased,1,_IndexOneBased)
AND
SysFactAtIndex(_InPredicate,_Arity,_IndexOneBased,_OutPredicate)
THEN
DB_NOOP(1);
//END_REGION

//REGION Stacks
// Add a value at the back of the stack: PROC_Stack_AddLast((STRING)_StackID, (GUIDSTRING)_Value)
// Add a value at the front of the stack: PROC_Stack_AddFirst((STRING)_StackID, (GUIDSTRING)_Value)
// Get and remove the last value of the stack: QRY_Stack_ExtractLast((STRING)_StackID) -> value in DB_QRYRTN_Stack_ExtractLast((GUIDSTRING)_Value)
// Get and remove the first value of the stack: QRY_Stack_ExtractFirst((STRING)_StackID)  -> value in DB_QRYRTN_Stack_ExtractFirst((GUIDSTRING)_Value)
PROC
PROC_Stack_AddLast((STRING)_StackID, (GUIDSTRING)_Value)
THEN
DB_Stack(_StackID, _Value);

PROC
PROC_Stack_AddFirst((STRING)_StackID, (GUIDSTRING)_Value)
THEN
DB_Stack(_StackID, _Value);
PROC_Stack_RestackOldValues(_StackID, _Value);

PROC
PROC_Stack_RestackOldValues((STRING)_StackID, (GUIDSTRING)_ExemptValue)
AND
DB_Stack(_StackID, _Value)
AND
_Value != _ExemptValue
THEN
NOT DB_Stack(_StackID, _Value);
DB_Stack(_StackID, _Value);

QRY
QRY_Stack_ExtractLast((STRING)_StackID)
AND
QRY_Stack_Internal_ClearExtractLast()
AND
DB_Stack(_StackID, _Value)
THEN
DB_QRYRTN_Stack_ExtractLast(_Value);

QRY
QRY_Stack_ExtractLast((STRING)_StackID)
AND
DB_QRYRTN_Stack_ExtractLast(_Value)
THEN
NOT DB_Stack(_StackID, _Value);

QRY
QRY_Stack_Internal_ClearExtractLast()
THEN
PROC_Stack_Internal_ClearExtractLast();

PROC
PROC_Stack_Internal_ClearExtractLast()
AND
DB_QRYRTN_Stack_ExtractLast((GUIDSTRING)_Value)
THEN
NOT DB_QRYRTN_Stack_ExtractLast(_Value);

IF
DB_QRYRTN_Stack_ExtractLast((GUIDSTRING)_NewValue)
AND
DB_QRYRTN_Stack_ExtractLast((GUIDSTRING)_OldValue)
AND
_NewValue != _OldValue
THEN
NOT DB_QRYRTN_Stack_ExtractLast(_OldValue);

QRY
QRY_Stack_ExtractFirst((STRING)_StackID)
AND
QRY_Stack_Internal_ClearExtractFirst()
AND
QRY_OnlyOnce_Reset("Stack_ExtractFirst")
AND
DB_Stack(_StackID, _Value)
AND
QRY_OnlyOnce("Stack_ExtractFirst")
THEN
DB_QRYRTN_Stack_ExtractFirst(_Value);

QRY
QRY_Stack_ExtractFirst((STRING)_StackID)
AND
DB_QRYRTN_Stack_ExtractFirst(_Value)
THEN
NOT DB_Stack(_StackID, _Value);

QRY
QRY_Stack_Internal_ClearExtractFirst()
THEN
PROC_Stack_Internal_ClearExtractFirst();

PROC
PROC_Stack_Internal_ClearExtractFirst()
AND
DB_QRYRTN_Stack_ExtractFirst((GUIDSTRING)_Value)
THEN
NOT DB_QRYRTN_Stack_ExtractFirst(_Value);
//END_REGION

//REGION Unpack GUID database (up to 6 entries)
// Helper that converts up to the first six elements of a database to procedure call parameters (via a callback)
//
//   PROC_UnpackDB_Callback(_CallbackID, _CallbackArgument, _Element1);
//   ..
//   PROC_UnpackDB_Callback((STRING)_CallbackID, (GUIDSTRING)_CallbackArgument, (GUIDSTRING)_Element1, (GUIDSTRING)_Element2, (GUIDSTRING)_Element3, (GUIDSTRING)_Element4, (GUIDSTRING)_Element5, (GUIDSTRING)_Element6)
//     - The called callbacks with the unpacked DB elements depending on specified _ArgCount (overload to catch the result)
//
// PROC_UnpackDB((STRING)_DBName, (STRING)_CallbackID, (GUIDSTRING)_CallbackArgument, (INTEGER)_CallbackArgCount, (GUIDSTRING)_EmptyFiller)
//   - _DBName: Database (with 1 column!) that contains the elements to unpack
//   - _CallbackID: String used for recognising the callback with the unpacked elements
//   - _CallbackArgument: Extra argument passed to the callback
//   - _CallbackArgCount: how many arguments should be passed to the callback. Maximum supported count: 6!
//   - _EmptyFiller: if _DBName contains fewer than _CallbackArgCount elements, the rest of the arguments will be _EmptyFiller
//
//
PROC
PROC_UnpackDB((STRING)_DBName, (STRING)_CallbackID, (GUIDSTRING)_CallbackArgument, (INTEGER)_CallbackArgCount, (GUIDSTRING)_EmptyFiller)
AND
SysCount(_DBName, 1, _RowCount)
THEN
PROC_DeclareCounter("GLO_UnpackIndex");
PROC_IncreaseCounter("GLO_UnpackIndex");
SysClear("DB_UnpackedIndexed", 2);
PROC_UnpackDB_Init(_DBName, _CallbackID, _CallbackArgument, _CallbackArgCount, _EmptyFiller, _RowCount);

PROC
PROC_UnpackDB_Init((STRING)_DBName, (STRING)_CallbackID, (GUIDSTRING)_CallbackArgument, (INTEGER)_CallbackArgCount, (GUIDSTRING)_EmptyFiller, (INTEGER)_RowCount)
AND
_CallbackArgCount > 6
THEN
DebugBreak("PROC_UnpackDB only supports callbacks with up to six elements");

PROC
PROC_UnpackDB_Init((STRING)_DBName, (STRING)_CallbackID, (GUIDSTRING)_CallbackArgument, (INTEGER)_CallbackArgCount, (GUIDSTRING)_EmptyFiller, (INTEGER)_RowCount)
AND
_CallbackArgCount <= 6
THEN
PROC_UnpackDB_Recursive(_DBName, _CallbackArgCount, _EmptyFiller, _RowCount);
PROC_UnpackDB_PerformCallback(_CallbackID, _CallbackArgument, _CallbackArgCount);

PROC
PROC_UnpackDB_PerformCallback((STRING)_CallbackID, (GUIDSTRING)_CallbackArgument, 1)
AND
DB_UnpackedIndexed(1, _Element1)
THEN
PROC_UnpackDB_Callback(_CallbackID, _CallbackArgument, _Element1);

PROC
PROC_UnpackDB_Callback((STRING)_CallbackID, (GUIDSTRING)_CallbackArgument, (GUIDSTRING)_Element1)
THEN
DB_NOOP(1);

PROC
PROC_UnpackDB_PerformCallback((STRING)_CallbackID, (GUIDSTRING)_CallbackArgument, 2)
AND
DB_UnpackedIndexed(1, _Element1)
AND
DB_UnpackedIndexed(2, _Element2)
THEN
PROC_UnpackDB_Callback(_CallbackID, _CallbackArgument, _Element1, _Element2);

PROC
PROC_UnpackDB_Callback((STRING)_CallbackID, (GUIDSTRING)_CallbackArgument, (GUIDSTRING)_Element1, (GUIDSTRING)_Element2)
THEN
DB_NOOP(1);

PROC
PROC_UnpackDB_PerformCallback((STRING)_CallbackID, (GUIDSTRING)_CallbackArgument, 3)
AND
DB_UnpackedIndexed(1, _Element1)
AND
DB_UnpackedIndexed(2, _Element2)
AND
DB_UnpackedIndexed(3, _Element3)
THEN
PROC_UnpackDB_Callback(_CallbackID, _CallbackArgument, _Element1, _Element2, _Element3);

PROC
PROC_UnpackDB_Callback((STRING)_CallbackID, (GUIDSTRING)_CallbackArgument, (GUIDSTRING)_Element1, (GUIDSTRING)_Element2, (GUIDSTRING)_Element3)
THEN
DB_NOOP(1);

PROC
PROC_UnpackDB_PerformCallback((STRING)_CallbackID, (GUIDSTRING)_CallbackArgument, 4)
AND
DB_UnpackedIndexed(1, _Element1)
AND
DB_UnpackedIndexed(2, _Element2)
AND
DB_UnpackedIndexed(3, _Element3)
AND
DB_UnpackedIndexed(4, _Element4)
THEN
PROC_UnpackDB_Callback(_CallbackID, _CallbackArgument, _Element1, _Element2, _Element3, _Element4);

PROC
PROC_UnpackDB_Callback((STRING)_CallbackID, (GUIDSTRING)_CallbackArgument, (GUIDSTRING)_Element1, (GUIDSTRING)_Element2, (GUIDSTRING)_Element3, (GUIDSTRING)_Element4)
THEN
DB_NOOP(1);

PROC
PROC_UnpackDB_PerformCallback((STRING)_CallbackID, (GUIDSTRING)_CallbackArgument, 5)
AND
DB_UnpackedIndexed(1, _Element1)
AND
DB_UnpackedIndexed(2, _Element2)
AND
DB_UnpackedIndexed(3, _Element3)
AND
DB_UnpackedIndexed(4, _Element4)
AND
DB_UnpackedIndexed(5, _Element5)
THEN
PROC_UnpackDB_Callback(_CallbackID, _CallbackArgument, _Element1, _Element2, _Element3, _Element4, _Element5);

PROC
PROC_UnpackDB_Callback((STRING)_CallbackID, (GUIDSTRING)_CallbackArgument, (GUIDSTRING)_Element1, (GUIDSTRING)_Element2, (GUIDSTRING)_Element3, (GUIDSTRING)_Element4, (GUIDSTRING)_Element5)
THEN
DB_NOOP(1);

PROC
PROC_UnpackDB_PerformCallback((STRING)_CallbackID, (GUIDSTRING)_CallbackArgument, 6)
AND
DB_UnpackedIndexed(1, _Element1)
AND
DB_UnpackedIndexed(2, _Element2)
AND
DB_UnpackedIndexed(3, _Element3)
AND
DB_UnpackedIndexed(4, _Element4)
AND
DB_UnpackedIndexed(5, _Element5)
AND
DB_UnpackedIndexed(6, _Element6)
THEN
PROC_UnpackDB_Callback(_CallbackID, _CallbackArgument, _Element1, _Element2, _Element3, _Element4, _Element5, _Element6);

PROC
PROC_UnpackDB_Callback((STRING)_CallbackID, (GUIDSTRING)_CallbackArgument, (GUIDSTRING)_Element1, (GUIDSTRING)_Element2, (GUIDSTRING)_Element3, (GUIDSTRING)_Element4, (GUIDSTRING)_Element5, (GUIDSTRING)_Element6)
THEN
DB_NOOP(1);

PROC
PROC_UnpackDB_Recursive((STRING)_DBName, (INTEGER)_CallbackArgCount, (GUIDSTRING)_EmptyFiller, (INTEGER)_RowCount)
AND
DB_GlobalCounter("GLO_UnpackIndex", _Index)
AND
_Index <= _CallbackArgCount
AND
_Index <= _RowCount
AND
SysFactAtIndex(_DBName, 1, _Index, "DB_UnpackTemp")
AND
DB_UnpackTemp((GUIDSTRING)_Element)
THEN
NOT DB_UnpackTemp(_Element);
DB_UnpackedIndexed(_Index, _Element);
PROC_IncreaseCounter("GLO_UnpackIndex");
PROC_UnpackDB_Recursive(_DBName, _CallbackArgCount, _EmptyFiller, _RowCount);

PROC
PROC_UnpackDB_Recursive((STRING)_DBName, (INTEGER)_CallbackArgCount, (GUIDSTRING)_EmptyFiller, (INTEGER)_RowCount)
AND
DB_GlobalCounter("GLO_UnpackIndex", _Index)
AND
_Index <= _CallbackArgCount
AND
_Index > _RowCount
THEN
DB_UnpackedIndexed(_Index, _EmptyFiller);
PROC_IncreaseCounter("GLO_UnpackIndex");
PROC_UnpackDB_Recursive(_DBName, _CallbackArgCount, _EmptyFiller, _RowCount);

//END_REGION

//REGION Default Parameters
PROC
PlayAnimation((GUIDSTRING)_Object,(ANIMATION)_String)
THEN
PlayAnimation(_Object,_String,"");

PROC
TeleportTo((GUIDSTRING)_Object,(GUIDSTRING)_Target)
THEN
TeleportTo(_Object,_Target,"",1,0,1,0,1);

PROC
TeleportToPosition((GUIDSTRING)_Object,(REAL)_X,(REAL)_Y,(REAL)_Z)
THEN
TeleportToPosition(_Object,_X,_Y,_Z,"",1,0,1,0,1);

PROC
TeleportTo((GUIDSTRING)_Object,(GUIDSTRING)_Target,(STRING)_Event)
THEN
TeleportTo(_Object,_Target,_Event,1,0,1,0,1);

PROC
TeleportTo((GUIDSTRING)_Object,(GUIDSTRING)_Target,(STRING)_Event,(INTEGER)_TeleportLinkedCharacters)
THEN
TeleportTo(_Object,_Target,_Event,_TeleportLinkedCharacters,0,1,0,1);

PROC
TeleportTo((GUIDSTRING)_Object,(GUIDSTRING)_Target,(STRING)_Event,(INTEGER)_TeleportLinkedCharacters,(INTEGER)_TeleportPartyMembers)
THEN
TeleportTo(_Object,_Target,_Event,_TeleportLinkedCharacters,_TeleportPartyMembers,1,0,1);

PROC
TeleportToPosition((GUIDSTRING)_Object,(REAL)_X,(REAL)_Y,(REAL)_Z,(STRING)_Event,(INTEGER)_TeleportLinkedCharacters)
THEN
TeleportToPosition(_Object,_X,_Y,_Z,_Event,_TeleportLinkedCharacters,0,1,0,1);

PROC
TeleportTo((GUIDSTRING)_Object,(GUIDSTRING)_Target,(STRING)_Event,(INTEGER)_TeleportLinkedCharacters,(INTEGER)_TeleportPartyMembers,(INTEGER)_LeaveCombat)
THEN
TeleportTo(_Object,_Target,_Event,_TeleportLinkedCharacters,_TeleportPartyMembers,1,_LeaveCombat,1);

PROC
TeleportToPosition((GUIDSTRING)_Object,(REAL)_X,(REAL)_Y,(REAL)_Z,(STRING)_Event,(INTEGER)_TeleportLinkedCharacters,(INTEGER)_TeleportPartyMembers,(INTEGER)_LeaveCombat)
THEN
TeleportToPosition(_Object,_X,_Y,_Z,_Event,_TeleportLinkedCharacters,_TeleportPartyMembers,1,_LeaveCombat,1);

PROC
PROC_TeleportPartiesTo((TRIGGER)_Trigger,(STRING)_Event)
THEN
TeleportPartiesWithMovie(_Trigger,_Event,"");

PROC
ApplyStatus((GUIDSTRING)_Target,(STRING)_Status,(REAL)_Duration)
THEN
ApplyStatus(_Target,_Status,_Duration,0);

PROC
SetFlag((FLAG)_Flag)
THEN
SetFlag((FLAG)_Flag, NULL_00000000-0000-0000-0000-000000000000, 0);

PROC
SetFlag((FLAG)_Flag, (GUIDSTRING)_Object)
THEN
SetFlag((FLAG)_Flag, _Object, 0);

PROC
SetFlag((FLAG)_Flag, (GUIDSTRING)_Object, (INTEGER)_DialogInstance)
THEN
SetFlag((FLAG)_Flag, _Object, _DialogInstance, 1);

PROC
ClearFlag((FLAG)_Flag)
THEN
ClearFlag((FLAG)_Flag, NULL_00000000-0000-0000-0000-000000000000, 0);

PROC
ClearFlag((FLAG)_Flag, (GUIDSTRING)_Object)
THEN
ClearFlag((FLAG)_Flag, _Object, 0);

PROC
ClearFlag((FLAG)_Flag, (GUIDSTRING)_Object, (INTEGER)_DialogInstance)
THEN
ClearFlag((FLAG)_Flag, _Object, _DialogInstance, 1);

//REGION UseSpell Overloads
PROC
UseSpell((GUIDSTRING)_Character,(STRING)_SpellID,(GUIDSTRING)_Target)
THEN
UseSpell(_Character,_SpellID,_Target,NULL_00000000-0000-0000-0000-000000000000);

PROC
UseSpell((GUIDSTRING)_Caster, (STRING)_SpellID, (GUIDSTRING)_Target, (GUIDSTRING)_Target2)
THEN
UseSpell(_Caster, _SpellID, _Target, _Target2, 0);

PROC
UseSpellAtPosition((GUIDSTRING)_Caster, (STRING)_SpellID, (REAL)_X, (REAL)_Y, (REAL)_Z)
THEN
UseSpellAtPosition(_Caster, _SpellID, _X, _Y, _Z, 0);
//END_REGION

PROC
MakePlayer((CHARACTER)_Character)
THEN
MakePlayer((CHARACTER)_Character,NULL_00000000-0000-0000-0000-000000000000);

PROC
Die((GUIDSTRING)_Target, (DEATHTYPE)_DeathType, (GUIDSTRING)_Source, (INTEGER)_GenerateTreasure, (INTEGER)_Immediate)
THEN
Die(_Target, _DeathType, _Source, _GenerateTreasure, _Immediate, 0.0);

PROC
ActivateTrade((CHARACTER)_Player, (CHARACTER)_Trader, (INTEGER)_CanSell)
THEN
ActivateTrade(_Player, _Trader, _CanSell, TRADEMODE.Trade);

PROC
ActivateTrade((CHARACTER)_Player, (CHARACTER)_Trader, (INTEGER)_CanSell, (TRADEMODE)_StartAsTrade)
THEN
ActivateTrade(_Player, _Trader, _CanSell, _StartAsTrade, NULL_00000000-0000-0000-0000-000000000000, "");

PROC
Pickup((CHARACTER)_Char,(ITEM)_Item,(STRING)_Event)
THEN
Pickup(_Char,_Item,_Event,1);
//END_REGION

//REGION Global Event Memory
IF
FlagSet((FLAG)_String, NULL_00000000-0000-0000-0000-000000000000, _) // flagType: Global
THEN
DB_GlobalFlag((FLAG)_String); // flagType: Global

IF
FlagCleared((FLAG)_String, NULL_00000000-0000-0000-0000-000000000000, _) // flagType: Global
THEN
NOT DB_GlobalFlag((FLAG)_String); // flagType: Global

PROC
PROC_GlobalSetFlagAndCache((FLAG)_String)
AND
_String != NULL_00000000-0000-0000-0000-000000000000
THEN
SetFlag((FLAG)_String, NULL_00000000-0000-0000-0000-000000000000, 0); // flagType: Global
DB_GlobalFlag((FLAG)_String); // flagType: Global

PROC
PROC_GlobalClearFlagAndCache((FLAG)_String)
AND
_String != NULL_00000000-0000-0000-0000-000000000000
THEN
ClearFlag((FLAG)_String, NULL_00000000-0000-0000-0000-000000000000, 0); // flagType: Global
NOT DB_GlobalFlag((FLAG)_String); // flagType: Global
//END_REGION

//REGION Poof / Foop
PROC
PROC_Poof((GUIDSTRING)_Character)
THEN
PROC_Poof((GUIDSTRING)_Character,EFFECTRESOURCEGUID_VFX_Script_Stub_Poof_01_f0cf792a-0f74-d17e-ad0d-6052a6131416);

PROC
PROC_Poof((GUIDSTRING)_Character,(EFFECTRESOURCE)_Effect)
AND
GetRegion(_Character,_Region)
AND
DB_CurrentLevel(_Region)
AND
GetPosition(_Character,_X,_Y,_Z)
THEN
PlayEffectAtPosition(_Effect,_X,_Y,_Z);

PROC
PROC_Poof((GUIDSTRING)_Object,(EFFECTRESOURCE)_Effect)
THEN
PROC_SetOnStage(_Object,0);


PROC
PROC_Foop((GUIDSTRING)_Object)
THEN
PROC_Foop(_Object, EFFECTRESOURCEGUID_VFX_Script_Stub_Poof_01_f0cf792a-0f74-d17e-ad0d-6052a6131416);

PROC
PROC_Foop((GUIDSTRING)_Object,(EFFECTRESOURCE)_Effect)
AND
GetRegion(_Object,_Region)
AND
DB_CurrentLevel(_Region)
AND
GetPosition(_Object,_X,_Y,_Z)
THEN
PlayEffectAtPosition(_Effect,_X,_Y,_Z);

PROC
PROC_Foop((GUIDSTRING)_Object,(EFFECTRESOURCE)_Effect)
THEN
PROC_SetOnStage(_Object,1);

IF
FlagSet((FLAG)GLO_Event_Poof_32404a82-0cd9-e68e-4bd9-30257387e857,_Target,_)
THEN
PROC_Poof(_Target);
ClearFlag((FLAG)GLO_Event_Poof_32404a82-0cd9-e68e-4bd9-30257387e857,_Target);

IF
EntityEvent(_Character,"GEN_GoOffStage")
THEN
SetOnStage(_Character,0);

IF
ObjectTimerFinished((GUIDSTRING)_Object,"Poof")
THEN
PROC_Poof(_Object);

IF
ObjectTimerFinished((GUIDSTRING)_Object,"Foop")
THEN
PROC_Foop(_Object);

PROC
PROC_SetOnStage((GUIDSTRING)_Object,1)
THEN
SetOnStage(_Object,1);
NOT DB_OffStage(_Object);

PROC
PROC_SetOnStage((GUIDSTRING)_Object,0)
THEN
SetOnStage(_Object,0);
DB_OffStage(_Object);
//END_REGION

//REGION Uniformly distributed Randoms (Fair random with memory)
//Fair rand requires a UUID and a maxamount. The function will return [0,Maxamount-1]
//When no previous data found, all possible numbers are added into an array.
//Every FairRand query returns one random number from the array and removes it.
//Only when the array is empty, is it reseeded.
//Output: DB_FairRand_ReturnVal(INTEGER)

//Clear return value
QRY
QRY_GetFairRand((STRING)_UUID,(INTEGER)_Amount)
AND
DB_FairRand_ReturnVal((INTEGER)_Number)
THEN
NOT DB_FairRand_ReturnVal(_Number);

//If first time or all numbers used: reseed.
QRY
QRY_GetFairRand((STRING)_UUID,(INTEGER)_Amount)
AND
NOT DB_FairRand_Available(_UUID,_Amount,_)
THEN
PROC_SeedFairRand(_UUID,_Amount,_Amount);

//Pick a random number from the available array (Put in new array with indeces, pick random index, return number)
//Special case: Make sure that the first pick of a list is not the same as the last pick of the previous list
QRY
QRY_GetFairRand((STRING)_UUID,(INTEGER)_Amount)
THEN
DB_FairRandAmount(0);

QRY
QRY_GetFairRand((STRING)_UUID,(INTEGER)_Amount)
AND
_Amount > 1
AND
DB_FairRand_Last_Of_Previous_Seeding(_PreviousNumber)
AND
DB_FairRand_Available(_UUID,_Amount,_AvailableNumber)
AND
_PreviousNumber != _AvailableNumber
AND
DB_FairRandAmount(_Count)
AND
IntegerSum(_Count,1,_NewCount)
THEN
DB_FairRand_Array(_Count,_AvailableNumber);
NOT DB_FairRandAmount(_Count);
DB_FairRandAmount(_NewCount);
DB_FairAmount_ListFilled(1);

QRY
QRY_GetFairRand((STRING)_UUID,(INTEGER)_Amount)
AND
DB_FairRand_Last_Of_Previous_Seeding(_Number)
THEN
NOT DB_FairRand_Last_Of_Previous_Seeding(_Number);

QRY
QRY_GetFairRand((STRING)_UUID,(INTEGER)_Amount)
AND
NOT DB_FairAmount_ListFilled(1)
AND
DB_FairRand_Available(_UUID,_Amount,_AvailableNumber)
AND
DB_FairRandAmount(_Count)
AND
IntegerSum(_Count,1,_NewCount)
THEN
DB_FairRand_Array(_Count,_AvailableNumber);
NOT DB_FairRandAmount(_Count);
DB_FairRandAmount(_NewCount);

QRY
QRY_GetFairRand((STRING)_UUID,(INTEGER)_Amount)
AND
DB_FairAmount_ListFilled(1)
THEN
NOT DB_FairAmount_ListFilled(1);

QRY
QRY_GetFairRand((STRING)_UUID,(INTEGER)_Amount)
AND
DB_FairRandAmount(_Count)
AND
_Count > 0
AND
Random(_Count,_Index)
AND
DB_FairRand_Array(_Index,_Number)
THEN
NOT DB_FairRand_Available(_UUID,_Amount,_Number);
DB_FairRand_ReturnVal(_Number);

//If this was the last value in the available list, remember it, so we don't pick it first in the next list.
QRY
QRY_GetFairRand((STRING)_UUID,(INTEGER)_Amount)
AND
NOT DB_FairRand_Available(_UUID,_Amount,_)
AND
DB_FairRand_ReturnVal(_Number)
THEN
DB_FairRand_Last_Of_Previous_Seeding(_Number);

//Clean up temp vars
QRY
QRY_GetFairRand((STRING)_UUID,(INTEGER)_MaxAmount)
AND
DB_FairRandAmount(_Amount)
THEN
NOT DB_FairRandAmount(_Amount);

QRY
QRY_GetFairRand((STRING)_UUID,(INTEGER)_Amount)
AND
DB_FairRand_Array(_Index,_Number)
THEN
NOT DB_FairRand_Array(_Index,_Number);

PROC
PROC_SeedFairRand((STRING)_UUID,(INTEGER)_MaxAmount,(INTEGER)_Amount)
AND
_Amount > 0
AND
IntegerSubtract(_Amount,1,_NewAmount)
THEN
DB_FairRand_Available(_UUID,_MaxAmount,_NewAmount);
PROC_SeedFairRand(_UUID,_MaxAmount,_NewAmount);
//END_REGION

//REGION Get Random position in coordinate-based area ignoring AI grid
// Pass in two objects. Returns point within cube defined by their coordinates
// Returns result in DB_Helper_GetAnyRandomPositionInArea_Result(_X,_Y,_Z)
// NOTE: only tested currently with all coordinates of FirstPoint <= coordinates of _SecondPoint
//   I don't know whether our random can handle a negative module.
QRY
QRY_Helper_GetAnyRandomPositionInArea((GUIDSTRING)_FirstPoint,(GUIDSTRING)_SecondPoint)
AND
DB_Helper_GetAnyRandomPositionInArea_Result(_X,_Y,_Z)
THEN
NOT DB_Helper_GetAnyRandomPositionInArea_Result(_X,_Y,_Z);

QRY
QRY_Helper_GetAnyRandomPositionInArea((GUIDSTRING)_BottomLeftBack,(GUIDSTRING)_TopRightFront)
AND
GetPosition(_BottomLeftBack,_X1,_Y1,_Z1)
AND
GetPosition(_TopRightFront,_X2,_Y2,_Z2)
AND
RealSubtract(_X2,_X1,_XDeltaReal)
AND
RealSubtract(_Y2,_Y1,_YDeltaReal)
AND
RealSubtract(_Z2,_Z1,_ZDeltaReal)
AND
RealProduct(_XDeltaReal,100.0,_XScaledDeltaReal)
AND
RealProduct(_YDeltaReal,100.0,_YScaledDeltaReal)
AND
RealProduct(_ZDeltaReal,100.0,_ZScaledDeltaReal)
AND
RealToInteger(_XScaledDeltaReal,_XScaledDeltaInt)
AND
RealToInteger(_YScaledDeltaReal,_YScaledDeltaInt)
AND
RealToInteger(_ZScaledDeltaReal,_ZScaledDeltaInt)
AND
Random(_XScaledDeltaInt,_XRandScaledDeltaInt)
AND
Random(_YScaledDeltaInt,_YRandScaledDeltaInt)
AND
Random(_ZScaledDeltaInt,_ZRandScaledDeltaInt)
AND
IntegerToReal(_XRandScaledDeltaInt,_XRandScaledDeltaReal)
AND
IntegerToReal(_YRandScaledDeltaInt,_YRandScaledDeltaReal)
AND
IntegerToReal(_ZRandScaledDeltaInt,_ZRandScaledDeltaReal)
AND
RealDivide(_XRandScaledDeltaReal,100.0,_XRandDeltaReal)
AND
RealDivide(_YRandScaledDeltaReal,100.0,_YRandDeltaReal)
AND
RealDivide(_ZRandScaledDeltaReal,100.0,_ZRandDeltaReal)
AND
RealSum(_X1,_XRandDeltaReal,_NewX)
AND
RealSum(_Y1,_YRandDeltaReal,_NewY)
AND
RealSum(_Z1,_ZRandDeltaReal,_NewZ)
THEN
DB_Helper_GetAnyRandomPositionInArea_Result(_NewX,_NewY,_NewZ);
//END_REGION

//REGION Singleton Variables //A variable which can only hold one value. All old value get overwritten.
IF
DB_Singleton(_VariableNam,_NewValue)
AND
DB_Singleton(_VariableNam,_OldValue)
AND
_NewValue != _OldValue
THEN
NOT DB_Singleton(_VariableNam,_OldValue);

IF
DB_Singleton_GUID(_VariableNam,(GUIDSTRING)_NewValue)
AND
DB_Singleton_GUID(_VariableNam,_OldValue)
AND
_NewValue != _OldValue
THEN
NOT DB_Singleton_GUID(_VariableNam,_OldValue);
//END_REGION

//REGION Only Once Rule Query
QRY
QRY_OnlyOnce((STRING)_OnlyOnceUUID)
AND
NOT DB_OnlyOnce(_OnlyOnceUUID)
THEN
DB_OnlyOnce(_OnlyOnceUUID);

QRY
QRY_OnlyOnce_IsSet((STRING)_OnlyOnceUUID)
AND
DB_OnlyOnce(_OnlyOnceUUID)
THEN
DB_NOOP(1);

QRY
QRY_OnlyOnce_Reset((STRING)_OnlyOnceUUID)
THEN
NOT DB_OnlyOnce(_OnlyOnceUUID);
//END_REGION

//REGION Only once per user
QRY
QRY_OnlyOncePerUser((CHARACTER)_Player,(STRING)_SituationID)
AND
GetReservedUserID(_Player,_UserID)
AND
GetUserProfileID(_UserID,_ProfileID)
AND
NOT DB_OnlyOnce_PerUser(_ProfileID,_SituationID)
THEN
DB_OnlyOnce_PerUser(_ProfileID,_SituationID);

QRY
QRY_OnlyOncePerUser_Reset((STRING)_SituationID)
AND
DB_OnlyOnce_PerUser(_ProfileID,_SituationID)
THEN
NOT DB_OnlyOnce_PerUser(_ProfileID,_SituationID);
//END_REGION

//REGION Only once per user, but also mark users of nearby players
// NOTE: this is intended as replacement for triggering ADs guarded by a
//   QRY_OnlyOnce(). It does not check for all corner cases, such as
//   character reassignment to another user. It's just meant to increase
//   the chances that every user will see an AD rather than only the first
//   one.

// Use for atmospheric ADs that don't influence progression, and which are
// nice for a player to see/hear at least once. It avoids playing the same
// AD for multiple users in case they already heard another user's player
// say it, and at the same time allows different users to have the same AD
// if they arrive at a spot/perform the same action at different times.
QRY
QRY_OncePerUserAndNearbyPlayers((CHARACTER)_Player,(STRING)_SituationID)
AND
QRY_OncePerUserAndNearbyPlayers(_Player,(STRING)_SituationID, 10.0)
THEN
DB_NOOP(1);

QRY
QRY_OncePerUserAndNearbyPlayers((CHARACTER)_Player,(STRING)_SituationID, (REAL)_Range)
AND
NOT QRY_OncePerUserAndNearbyPlayers_IsSet(_Player,_SituationID)
THEN
PROC_OncePerUserAndNearbyPlayers_Set(_Player,(STRING)_SituationID, _Range);

PROC
PROC_OncePerUserAndNearbyPlayers_Set((CHARACTER)_Player,(STRING)_SituationID, (REAL)_Range)
AND
DB_Players(_OtherPlayer)
AND
QRY_IsInRange(_Player,_OtherPlayer,_Range)
AND
GetReservedUserID(_OtherPlayer,_UserID)
AND
GetUserProfileID(_UserID,_ProfileID)
THEN
DB_OnlyOnce_PerUser(_ProfileID,_SituationID);

QRY
QRY_OncePerUserAndNearbyPlayers_IsSet((CHARACTER)_Player,(STRING)_SituationID)
AND
QRY_OncePerUserAndNearbyPlayers_IsSet(_Player,_SituationID,10.0)
THEN
DB_NOOP(1);

QRY
QRY_OncePerUserAndNearbyPlayers_IsSet((CHARACTER)_Player,(STRING)_SituationID,(REAL)_Range)
AND
DB_Players(_OtherPlayer)
AND
QRY_IsInRange(_Player,_OtherPlayer,_Range)
AND
GetReservedUserID(_OtherPlayer,_UserID)
AND
GetUserProfileID(_UserID,_ProfileID)
AND
DB_OnlyOnce_PerUser(_ProfileID,_SituationID)
THEN
DB_NOOP(1);

QRY
QRY_OncePerUserAndNearbyPlayers_Reset((STRING)_SituationID)
AND
DB_OnlyOnce_PerUser(_ProfileID,_SituationID)
THEN
NOT DB_OnlyOnce_PerUser(_ProfileID,_SituationID);

// so it always succeeds and can be used in series with any other cleaning
QRY
QRY_OncePerUserAndNearbyPlayers_Reset((STRING)_SituationID)
THEN
DB_NOOP(1);
//END_REGION

//REGION QRY_OnlyOnceForNearbyPlayers_Timeout (e.g. Playing a generic AD should only be done once every X seconds.)
QRY
QRY_OnlyOnceForNearbyPlayers_Timeout((CHARACTER)_Player,(STRING)_SituationID,(INTEGER)_Duration)
AND 
NOT DB_OnlyOncePerPlayer(_Player,_SituationID)
AND
DB_Players(_OtherPlayer)
AND
GetDistanceTo(_Player, _OtherPlayer, _Dist)
AND
_Dist < 10.0
THEN
DB_OnlyOncePerPlayer(_OtherPlayer,_SituationID);
ObjectTimerLaunch(_OtherPlayer,_SituationID,_Duration);

IF
ObjectTimerFinished((CHARACTER)_Player,_SituationID)
AND
DB_OnlyOncePerPlayer(_Player,_SituationID)
THEN
NOT DB_OnlyOncePerPlayer(_Player,_SituationID);
//END_REGION

//REGION Small macros
PROC
PROC_RemoveDialog((GUIDSTRING)_NPC)
THEN
DialogRequestStop(_NPC);
PROC_RemoveAllDialogEntriesForSpeaker(_NPC);
SetHasDialog(_Npc,0);
//END_REGION

//REGION Turn Skipping
//While in DB_CharacterSkipTurn(_Char), skip turn
//
IF
FlagSet(GEN_EndTurn_78cd5286-9c0d-4dea-9033-1d6276be52e5, _Char, _) // flagType: Object
THEN
EndTurn(_Char);
ClearFlag((FLAG)GEN_EndTurn_78cd5286-9c0d-4dea-9033-1d6276be52e5, _Char, 0); // flagType: Object

IF
FlagSet(GEN_SkipToTurn_9418ba09-2d39-40bc-81ec-f9d7a05310ce, _Char, _) // flagType: Object
AND
DB_Is_InCombat(_Char,_)
THEN
DB_CharacterSkipTurn(_Char);
ClearFlag((FLAG)GEN_SkipToTurn_9418ba09-2d39-40bc-81ec-f9d7a05310ce, _Char, 0); // flagType: Object

IF
TurnStarted(_Char)
AND
DB_CharacterSkipTurn(_Char)
THEN
EndTurn(_Char);

IF
TurnStarted(_Char)
AND
DB_SkipToCharactersTurn(_CharsTurn)
AND
DB_Is_InCombat(_Char,_ID)
AND
DB_Is_InCombat(_CharsTurn,_ID)
AND
_Char != _CharsTurn
THEN
EndTurn(_Char);

IF
TurnStarted(_Char)
AND
DB_SkipToCharactersTurn(_Char)
THEN
NOT DB_SkipToCharactersTurn(_Char);

IF
FlagSet(GEN_DisappearOutOfSight_5dc33889-cbfb-c3d2-9e4e-8d826bf8566f, (CHARACTER)_Char, _) // flagType: Object
THEN
PROC_DisappearOutOfSight(_Char,"Run",0,"");
ClearFlag((FLAG)GEN_DisappearOutOfSight_5dc33889-cbfb-c3d2-9e4e-8d826bf8566f, _Char, 0); // flagType: Object

IF
FlagSet((FLAG)GEN_DisappearOutOfSightWhenAvailable_a5b0b401-a04d-6493-579b-d87cff1474cb, (CHARACTER)_Char, _)
THEN
ClearFlag((FLAG)GEN_DisappearOutOfSightWhenAvailable_a5b0b401-a04d-6493-579b-d87cff1474cb, _Char , 0);
PROC_NotifyWhenReadyToMoveOn(_Char, "GLO_DisappearOutOfSight");

PROC
PROC_ReadyToMoveOn(_Char, "GLO_DisappearOutOfSight")
THEN
PROC_DisappearOutOfSight(_Char,"Run",0,"");
//END_REGION

//REGION Combat wait and end turn

PROC
PROC_WaitAndEndTurn((GUIDSTRING)_Object,(INTEGER)_WaitTime)
AND
IntegerToReal(_WaitTime,_WaitTimeReal)
AND
RealDivide(_WaitTimeReal,1000.0,_CombatWait)
THEN
SetEntityEventReal(_Object,"GLO_CombatWait",_CombatWait);
RealtimeObjectTimerLaunch(_Object,"GLO_EndTurn",_WaitTime);

IF
ObjectTimerFinished(_Object,"GLO_EndTurn")
THEN
EndTurn(_Object);

//END_REGION

//REGION Force End a Dialog
//for use in behaviour scripts 
IF
EntityEvent((GUIDSTRING)_Object,"ForceStopDialog")
THEN
PROC_ForceStopDialog(_Object);

PROC 
PROC_ForceStopDialog((GUIDSTRING)_Object)
AND
NOT DB_ObjectIsDialogSoftLocked(_,_Object)
THEN
DialogRequestStop(_Object);

PROC 
PROC_ForceStopDialog((GUIDSTRING)_Object)
AND
DB_ObjectIsDialogSoftLocked(_,_Object)
THEN
PROC_Inclusion_RemoveOrigin(_Object);

//unlike PROC_ForceStopDialog this PROC will only stop dialogs if they are fully started
//if the dialog is still loading, it will wait for the dialog to start before stopping it.
//this is marked as TEMP since we will/should get a code solution for this
PROC
PROC_TEMP_RequestStopDialog((GUIDSTRING)_Object)
AND
NOT DB_ObjectIsDialogSoftLocked(_,_Object)
AND
IsSpeakerReserved(_Object,_Reserved)
THEN
PROC_TryRequestStopDialog(_Object,_Reserved);

PROC
PROC_TEMP_RequestStopDialog((GUIDSTRING)_Object)
AND
DB_ObjectIsDialogSoftLocked(_,_Object)
THEN
PROC_Inclusion_RemoveOrigin(_Object);

//Not reserved, free to stop any ADs
PROC
PROC_TryRequestStopDialog((GUIDSTRING)_Object, 0)
THEN
DialogRequestStop(_Object);

//reserved, only stop dialogs that are fully started to prevent a black screen
PROC
PROC_TryRequestStopDialog((GUIDSTRING)_Object, 1)
AND 
SpeakerGetDialog(_Object, 0, _Dialog, _Inst)	//it's OK if this fails, that means the instance was already stopped, but not fully unloaded. 
THEN
PROC_StopDialogIfStarted(_Object, _Dialog, _Inst);

PROC
PROC_StopDialogIfStarted((GUIDSTRING)_Object,(DIALOGRESOURCE)_Dialog, (INTEGER)_Inst)
AND 
NOT DB_DialogName(_Dialog,_Inst)
THEN
DB_StopDialogsWhenStarted(_Object,_Inst); //we could have multiple entries for this instance, but that won't break anything. Saves us from having to track actor messages.

//fully started, free to kill
PROC
PROC_StopDialogIfStarted((GUIDSTRING)_Object,(DIALOGRESOURCE)_Dialog, (INTEGER)_Inst)
AND 
DB_DialogName(_Dialog,_Inst)
THEN
DialogRequestStop(_Object);

IF
DialogEnded(_, _Inst)
AND
DB_StopDialogsWhenStarted(_Object,_Inst)
THEN
NOT DB_StopDialogsWhenStarted(_Object,_Inst);

IF
DialogStarted(_,_Inst)
AND
DB_StopDialogsWhenStarted(_Object,_Inst)
THEN
DialogRequestStop(_Object);

//END_REGION

//REGION Force End if in this dialog

PROC
PROC_ForceStopSpecificDialog((GUIDSTRING)_Object, (DIALOGRESOURCE)_Dialog)
AND
DB_DialogName(_Dialog, _ID)
AND
DB_DialogPlayers(_ID, _Object, _)
THEN
PROC_ForceStopDialog(_Object);

PROC
PROC_ForceStopSpecificDialog((GUIDSTRING)_Object, (DIALOGRESOURCE)_Dialog)
AND
DB_DialogName(_Dialog, _ID)
AND
DB_DialogNPCs(_ID, _Object, _)
THEN
PROC_ForceStopDialog(_Object);

//END_REGION

//REGION Force End default dialog
QRY
QRY_IsDefaultDialogForObject((DIALOGRESOURCE)_Dialog, (GUIDSTRING)_Object)
AND
QRY_SelectDBDialogs(_Object, NULL_00000000-0000-0000-0000-000000000000)
AND
QRY_FoundDefaultDialogForSpeakerAndClear(_Dialog, _Object)
THEN
DB_NOOP(1);

QRY
QRY_IsDefaultDialogForObject((DIALOGRESOURCE)_Dialog, (GUIDSTRING)_Object)
AND
QRY_SelectDefaultDialog(_Object, NULL_00000000-0000-0000-0000-000000000000)
AND
QRY_FoundDefaultDialogForSpeakerAndClear(_Dialog, _Object)
THEN
DB_NOOP(1);

QRY
QRY_FoundDefaultDialogForSpeakerAndClear((DIALOGRESOURCE)_Dialog, (GUIDSTRING)_Object)
AND
DB_SelectedDialog(_Dialog, _Object)
THEN
NOT DB_SelectedDialog(_Dialog, _Object);

QRY
QRY_FoundDefaultDialogForSpeakerAndClear((DIALOGRESOURCE)_Dialog, (GUIDSTRING)_Object)
AND
DB_SelectedDialog(_Dialog, _Object, _Object2)
THEN
NOT DB_SelectedDialog(_Dialog, _Object, _Object2);

QRY
QRY_FoundDefaultDialogForSpeakerAndClear((DIALOGRESOURCE)_Dialog, (GUIDSTRING)_Object)
AND
DB_SelectedDialog(_Dialog, _Object, _Object2, _Object3)
THEN
NOT DB_SelectedDialog(_Dialog, _Object, _Object2, _Object3);

QRY
QRY_FoundDefaultDialogForSpeakerAndClear((DIALOGRESOURCE)_Dialog, (GUIDSTRING)_Object)
AND
DB_SelectedDialog(_Dialog, _Object, _Object2, _Object3, _Object4)
THEN
NOT DB_SelectedDialog(_Dialog, _Object, _Object2, _Object3, _Object4);
//END_REGION

//REGION Enemy surprised in next combat
IF
FlagSet((FLAG)GLO_Event_SetSurprisedNextCombat_5b4d1d25-1b70-43b2-b336-2f259eea3fc3,_Object,_DialogID)
THEN
PROC_MakeSurprised(_Object);
ClearFlag((FLAG)GLO_Event_SetSurprisedNextCombat_5b4d1d25-1b70-43b2-b336-2f259eea3fc3,_Object,0);
//END_REGION

//REGION Character Dies After Dialog Ends

IF
FlagSet(CharacterDieAfterDialog_fb62f715-13c3-c967-13f4-91f9231f8243, (CHARACTER)_Player, _Id) // flagType: Object
THEN
DB_CharacterDieAfterDialog(_Player,_Id);

IF
DialogEnded(_,_Id)
AND
DB_CharacterDieAfterDialog(_Player,_Id)
THEN
Die(_Player,DEATHTYPE.DoT,1);
ClearFlag((FLAG)CharacterDieAfterDialog_fb62f715-13c3-c967-13f4-91f9231f8243, _Player, _Id); // flagType: Object
NOT DB_CharacterDieAfterDialog(_Player,_Id);

//END_REGION

//REGION Generic hostile after dialog
//NPC in the dialogue will go hostile to the Player that this event is set on at the end of the dialog
IF
FlagSet(FactionHostileToIndivPlayerAfterDialog_3a7747bd-004a-6e69-7ff5-4f4eb6c3c223, (CHARACTER)_NPC, _Id) // flagType: Object
AND
NOT DB_Players(_NPC)
THEN
DB_HostileToIndivPlayerAfterDialog(_NPC,_Id);

IF
FlagSet(FactionHostileToIndivPlayerAfterDialog_3a7747bd-004a-6e69-7ff5-4f4eb6c3c223, (CHARACTER)_Player, _) // flagType: Object
AND
DB_Players(_Player)
AND
GUIDToString(_Player,_Name)
AND
Concatenate("FactionHostileToIndivPlayerAfterDialog was set on player ",_Name,_DebugStringA)
AND
Concatenate(_DebugStringA,". This flag was probably set on the wrong speaker.",_DebugStringOutput)
THEN
DebugBreak(_DebugStringOutput);

IF
FlagSet(FactionHostileToIndivPlayerAfterDialog_3a7747bd-004a-6e69-7ff5-4f4eb6c3c223, (CHARACTER)_NPC, _Id) // flagType: Object
THEN
ClearFlag((FLAG)FactionHostileToIndivPlayerAfterDialog_3a7747bd-004a-6e69-7ff5-4f4eb6c3c223, _NPC, _Id); // flagType: Object

IF
DialogEnded(_,_Id)
AND
DB_HostileToIndivPlayerAfterDialog(_NPC,_Id)
AND
GetFaction(_NPC,_NPCFaction)
AND
NOT QRY_FactionHostilityBlacklisted(_NPCFaction,1)
AND
NOT QRY_IsPlayerFaction(_NPCFaction)
AND
DB_DialogPlayers(_Id,_Player,_)
THEN
PROC_SetHostileToIndivPlayerFaction(_NPCFaction,(CHARACTER)_Player);

IF
DialogEnded(_,_Id)
AND
DB_HostileToIndivPlayerAfterDialog(_NPC,_Id)
THEN
NOT DB_HostileToIndivPlayerAfterDialog(_NPC,_Id);

//NPC in the dialogue will go hostile to the Player that this event is set on at the end of the dialog, and stay hostile to other players who attack it.
IF
FlagSet(FactionHostileToPlayerGroupAfterDialog_d73ce44b-1b9a-2e02-f29a-d8e9e68c7edc, (CHARACTER)_NPC, _Id) // flagType: Object
THEN
ClearFlag((FLAG)FactionHostileToPlayerGroupAfterDialog_d73ce44b-1b9a-2e02-f29a-d8e9e68c7edc, _NPC, _Id); // flagType: Object

IF
FlagSet(FactionHostileToPlayerGroupAfterDialog_d73ce44b-1b9a-2e02-f29a-d8e9e68c7edc, (CHARACTER)_NPC, _Id) // flagType: Object
AND
NOT DB_Players(_NPC)
THEN
DB_HostileToPlayerGroupAfterDialog(_NPC,_Id);

IF
FlagSet(FactionHostileToPlayerGroupAfterDialog_d73ce44b-1b9a-2e02-f29a-d8e9e68c7edc, (CHARACTER)_Player, _) // flagType: Object
AND
DB_Players(_Player)
AND
GUIDToString(_Player,_Name)
AND
Concatenate("FactionHostileToPlayerGroupAfterDialog was set on player ",_Name,_DebugStringA)
AND
Concatenate(_DebugStringA,". This flag was probably set on the wrong speaker.",_DebugStringOutput)
THEN
DebugBreak(_DebugStringOutput);

//If a player somehow gets the corresponding cancel flag for the same faction in the same dialogue as the one in which they got FactionHostileToPlayerGroupAfterDialog,
//you can't entirely disregard the cancel flag, but also can't end the dialogue without combat (because the ending node is probably written expecting combat).
//Therefore, the middle ground is to start a temporary hostility.
IF
DialogEnded(_,_Id)
AND
DB_HostileToPlayerGroupAfterDialog(_NPC,_Id)
AND
GetFaction(_NPC, _Faction)
AND
NOT QRY_FactionHostilityBlacklisted(_Faction,1)
AND
NOT QRY_IsPlayerFaction(_Faction)
AND
DB_DialogPlayers(_Id,_Player,_)
AND
DB_HostileToPlayerGroupCancelFlag((FLAG)_Flag, _Faction)
AND
DB_GlobalFlag((FLAG)_Flag)
THEN
NOT DB_HostileToPlayerGroupAfterDialog(_NPC,_Id);
DB_TemporaryHostilityAfterDialog(_NPC,_Id);
NOT DB_SetNeutralToPlayerGroupAfterDialog(_Id, (CHARACTER)_Player, _Faction);

IF
DialogEnded(_,_Id)
AND
DB_HostileToPlayerGroupAfterDialog(_NPC,_Id)
AND
GetFaction(_NPC, _Faction)
AND
NOT QRY_FactionHostilityBlacklisted(_Faction,1)
AND
NOT QRY_IsPlayerFaction(_Faction)
AND
DB_DialogPlayers(_Id,_Player,_)
AND
GetFaction(_Player, _PlayerFaction)
THEN
DB_HostileToPlayerGroup(_Faction, (CHARACTER) _Player);
NOT DB_HostileToPlayerGroupAfterDialog(_NPC,_Id);
SetHostileAndEnterCombat(_Faction, _PlayerFaction, _NPC, _Player);

IF
DialogEnded(_,_Id)
AND
DB_HostileToPlayerGroupAfterDialog(_NPC,_Id)
THEN
NOT DB_HostileToPlayerGroupAfterDialog(_NPC,_Id);

IF
DB_Is_InCombat(_Object, _ID)
THEN
PROC_GEN_UpdateHostilePlayerGroup(_Object, _ID);

PROC
PROC_GEN_UpdateHostilePlayerGroup((GUIDSTRING)_Object, (GUIDSTRING)_ID)
AND
DB_PartyMembers((CHARACTER)_Object)
THEN
SysClear("DB_HostileToPlayerGroup_FactionHandled", 1);

PROC
PROC_GEN_UpdateHostilePlayerGroup((GUIDSTRING)_Object, (GUIDSTRING)_ID)
AND
DB_PartyMembers((CHARACTER)_Object)
AND
DB_Is_InCombat(_Char, _ID)
AND
NOT DB_PartyMembers((CHARACTER)_Char)
AND
GetFaction(_Char, _Faction)
AND
NOT DB_HostileToPlayerGroup_FactionHandled(_Faction)
THEN
PROC_GEN_UpdateHostileToPlayerGroupForPartyMember(_Object, _Faction, _ID);
DB_HostileToPlayerGroup_FactionHandled(_Faction);

// NPC faction hostile to new party member added to combat ->
// also make hostile to other party members already in combat
PROC
PROC_GEN_UpdateHostileToPlayerGroupForPartyMember((CHARACTER)_PartyMember, (FACTION)_Faction, (GUIDSTRING)_ID)
AND
DB_HostileToPlayerGroup(_Faction, _PartyMember)
THEN
PROC_GEN_UpdateHostilePlayerGroupForFaction(_PartyMember, _Faction, _ID);


// Faction not yet hostile to new party member in combat, but hostile to another party member already
// in combat -> make hostile to the new party member as well
PROC
PROC_GEN_UpdateHostileToPlayerGroupForPartyMember((CHARACTER)_PartyMember, (FACTION)_Faction, (GUIDSTRING)_ID)
AND
NOT DB_HostileToPlayerGroup(_Faction, _PartyMember)
AND
DB_HostileToPlayerGroup(_Faction, _OtherPlayer)
AND
DB_Is_InCombat(_OtherPlayer, _ID)
AND
IsInPartyWith(_PartyMember, _OtherPlayer, 1)
THEN
DB_HostileToPlayerGroup(_Faction, _PartyMember);

// NPC joins combat -> if they are hostile to any existing player participant,
// also make them hostile to their party members in the same combat
PROC
PROC_GEN_UpdateHostilePlayerGroup((GUIDSTRING)_Object, (GUIDSTRING)_ID)
AND
NOT DB_PartyMembers((CHARACTER)_Object)
AND
GetFaction(_Object, _Faction)
AND
DB_HostileToPlayerGroup(_Faction, _Player)
AND
DB_Is_InCombat(_Player, _ID)
THEN
PROC_GEN_UpdateHostilePlayerGroupForFaction(_Player, _Faction, _ID);

PROC
PROC_GEN_UpdateHostilePlayerGroupForFaction((CHARACTER)_Player, (FACTION)_Faction, (GUIDSTRING)_ID)
AND
DB_PartyMembers(_OtherPartyMember)
AND
NOT DB_HostileToPlayerGroup(_Faction, _OtherPartyMember)
AND
DB_Is_InCombat(_OtherPartyMember, _ID)
AND
IsInPartyWith(_Player, _OtherPartyMember, 1)
THEN
DB_HostileToPlayerGroup(_Faction, _OtherPartyMember);

IF
DB_HostileToPlayerGroup(_Faction, _Player)
AND
GetFaction(_Player, _PlayerFaction)
AND
NOT QRY_FactionHostilityBlacklisted((FACTION)_Faction,1)
AND
NOT QRY_IsPlayerFaction(_Faction)
THEN
PROC_SetRelationMutual(_Faction, _PlayerFaction, 0);

// Keep DB_HostileToPlayerGroup for companions that leave the party,
// but clear it for followers/summons
IF
CharacterLeftParty(_Character)
AND
DB_PlayerSummons(_Character)
AND
DB_HostileToPlayerGroup(_Faction, _Character)
THEN
NOT DB_HostileToPlayerGroup(_Faction, _Character);

IF
CharacterLeftParty(_Character)
AND
DB_PartyFollowers(_Character)
AND
DB_HostileToPlayerGroup(_Faction, _Character)
THEN
NOT DB_HostileToPlayerGroup(_Faction, _Character);

IF
FlagSet(_Flag, _, _ID) // flagType: Object
AND
DB_HostileToPlayerGroupCancelFlag((FLAG)_Flag, _Faction)
AND
DB_HostileToPlayerGroupAfterDialog((CHARACTER)_NPC, _ID2)
AND
_ID2 != _ID
AND
DB_DialogPlayers(_ID2, _Player, _)
AND
GetFaction(_NPC,_Faction)
THEN
NOT DB_HostileToPlayerGroupAfterDialog(_NPC, _ID2);
DB_TemporaryHostilityAfterDialog(_NPC,_ID2);

IF
FlagSet(_Flag, _, _ID) // flagType: Object
AND
DB_HostileToPlayerGroupCancelFlag((FLAG)_Flag, _Faction)
AND
DB_HostileToPlayerGroupAfterDialog((CHARACTER)_NPC, _ID)
AND
GetFaction(_NPC,_Faction)
THEN
NOT DB_HostileToPlayerGroupAfterDialog(_NPC, _ID);

IF
DB_HostileToPlayerGroup(_Faction, _Player)
AND
DB_HostileToPlayerGroupCancelFlag((FLAG)_Flag, _Faction)
AND
GetFlag((FLAG)_Flag, NULL_00000000-0000-0000-0000-000000000000, 1)
THEN
NOT DB_HostileToPlayerGroup(_Faction, (CHARACTER)_Player);

IF
FlagSet((FLAG)_Flag, _, _)
AND
DB_HostileToPlayerGroupCancelFlag((FLAG)_Flag, _Faction)
AND
DB_HostileToPlayerGroup(_Faction, (CHARACTER)_Player)
THEN
PROC_HostileToPlayerGroupCancelFlag_TryCancel((CHARACTER)_Player, (FACTION)_Faction);

PROC
PROC_HostileToPlayerGroupCancelFlag_TryCancel((CHARACTER)_Player, (FACTION)_Faction)
THEN
PROC_HostileToPlayerGroupCancelFlag_TryCancel((CHARACTER)_Player, _Faction, 0);

PROC
PROC_HostileToPlayerGroupCancelFlag_TryCancel((CHARACTER)_Player, (FACTION)_Faction, 0)
THEN
NOT DB_HostileToPlayerGroup(_Faction, _Player);
PROC_SetRelationToPlayers(_Faction, 50);

PROC
PROC_HostileToPlayerGroupCancelFlag_TryCancel((CHARACTER)_Player, (FACTION)_Faction, 1)
THEN
NOT DB_HostileToPlayerGroup(_Faction, _Player);
PROC_ResetRelationMutual(_Faction, (FACTION)Hero_a1542c81-6895-929e-4522-10ce218bb360);

PROC
PROC_HostileToPlayerGroupCancelFlag_TryCancel((CHARACTER)_Player, (FACTION)_Faction, 0)
AND
IsSpeakerReserved(_Player, 0)
AND
GetFaction(_Player, _PlayerFaction)
THEN
ClearRelation(_Faction, _PlayerFaction);
ClearRelation(_PlayerFaction, _Faction);

PROC
PROC_HostileToPlayerGroupCancelFlag_TryCancel((CHARACTER)_Player, (FACTION)_Faction, 0)
AND
IsSpeakerReserved(_Player, 1)
AND
SpeakerGetDialog(_Player, 0, _, _ID)
AND
NOT QRY_HostileToPlayergroupAfterDialog_InHostileDialog((CHARACTER)_Player, _Faction, _ID)
THEN
DB_SetNeutralToPlayerGroupAfterDialog(_ID, _Player, _Faction);

QRY
QRY_HostileToPlayergroupAfterDialog_InHostileDialog((CHARACTER)_Player, (FACTION)_Faction, (INTEGER)_Id)
AND
DB_HostileToPlayerGroupAfterDialog((CHARACTER)_NPC, _Id)
AND
GetFaction(_NPC, _Faction)
THEN
DB_NOOP(1);

IF
DialogEnded(_, _ID)
AND
DB_SetNeutralToPlayerGroupAfterDialog(_ID, _Player, _Faction)
THEN
NOT DB_SetNeutralToPlayerGroupAfterDialog(_ID, _Player, _Faction);
PROC_HostileToPlayerGroupCancelFlag_TryCancel((CHARACTER)_Player, _Faction);

//Temp Hostility
IF
FlagSet(TemporaryHostilityAfterDialog_ca0cbe39-d121-069e-b408-c02954b32cf7, (CHARACTER)_NPC, _Id) // flagType: Object
AND
NOT DB_Players(_NPC)
THEN
DB_TemporaryHostilityAfterDialog(_NPC,_Id);

IF
FlagSet(TemporaryHostilityAfterDialog_ca0cbe39-d121-069e-b408-c02954b32cf7, (CHARACTER)_Player, _) // flagType: Object
AND
DB_Players(_Player)
AND
GUIDToString(_Player,_Name)
AND
Concatenate("TemporaryHostilityAfterDialog was set on player ",_Name,_DebugStringA)
AND
Concatenate(_DebugStringA,". This flag was probably set on the wrong speaker.",_DebugStringOutput)
THEN
DebugBreak(_DebugStringOutput);

IF
FlagSet(TemporaryHostilityAfterDialog_ca0cbe39-d121-069e-b408-c02954b32cf7, (CHARACTER)_NPC, _Id) // flagType: Object
THEN
ClearFlag((FLAG)TemporaryHostilityAfterDialog_ca0cbe39-d121-069e-b408-c02954b32cf7, _NPC, _Id); // flagType: Object

IF
DialogEnded(_,_Id)
AND
DB_TemporaryHostilityAfterDialog(_NPC,_Id)
AND
NOT QRY_ObjectFactionHostilityBlacklisted((GUIDSTRING)_NPC,1)
AND
NOT DB_Players((CHARACTER)_NPC)
AND
DB_DialogPlayers(_Id,_Player,_)
THEN
PROC_MakeNPCHostile((CHARACTER)_NPC,(CHARACTER)_Player);

IF
DialogEnded(_,_Id)
AND
DB_TemporaryHostilityAfterDialog(_NPC,_Id)
THEN
NOT DB_TemporaryHostilityAfterDialog(_NPC,_Id);

QRY
QRY_ObjectFactionHostilityBlacklisted((GUIDSTRING)_Object,(INTEGER)_Verbose)
AND
GetFaction(_Object, _Faction)
AND
QRY_FactionHostilityBlacklisted((FACTION)_Faction,(INTEGER)_Verbose)
THEN
DB_NOOP(1);

QRY
QRY_FactionHostilityBlacklisted((FACTION)_Faction,0)
AND
DB_FactionHostilityBlacklist(_Faction)
THEN
DB_NOOP(1);

QRY
QRY_FactionHostilityBlacklisted((FACTION)_Faction,1)
AND
DB_FactionHostilityBlacklist(_Faction)
AND
GUIDToString(_Faction, _FactionName)
AND
Concatenate("Trying to make faction hostile to players, but it should never be hostile to players: ", _FactionName, _Message)
THEN
DebugBreak(_Message);

// Hostility to all players set in dialog
IF
FlagSet(FactionHostileToAllPlayersAfterDialog_ca5c78dd-30e1-45fa-8c8b-dab6567a0f8e,(CHARACTER)_NPC,_Id)
THEN
ClearFlag(FactionHostileToAllPlayersAfterDialog_ca5c78dd-30e1-45fa-8c8b-dab6567a0f8e,_NPC,_Id);

IF
FlagSet(FactionHostileToAllPlayersAfterDialog_ca5c78dd-30e1-45fa-8c8b-dab6567a0f8e,(CHARACTER)_NPC,_Id)
AND
NOT DB_Players(_NPC)
THEN
DB_HostileToAllPlayersAfterDialog(_NPC,_Id);

IF
FlagSet(FactionHostileToAllPlayersAfterDialog_ca5c78dd-30e1-45fa-8c8b-dab6567a0f8e, (CHARACTER)_Player, _) // flagType: Object
AND
DB_Players(_Player)
AND
GUIDToString(_Player,_Name)
AND
Concatenate("FactionHostileToAllPlayersAfterDialog was set on player ",_Name,_DebugStringA)
AND
Concatenate(_DebugStringA,". This flag was probably set on the wrong speaker.",_DebugStringOutput)
THEN
DebugBreak(_DebugStringOutput);

// Hostility to all players set in dialogs overrides already set hostility to player group set in the same dialog
IF
DB_HostileToAllPlayersAfterDialog(_NPC,_Id)
AND
DB_HostileToPlayerGroupAfterDialog(_NPC,_Id)
THEN
NOT DB_HostileToPlayerGroupAfterDialog(_NPC,_Id);

// Checks like faction hostility blacklisted are performed by the PROC, so setting hostility this way still may fail
IF
DialogEnded(_Dialog,_Id)
AND
DB_HostileToAllPlayersAfterDialog(_NPC,_Id)
AND
GetFaction(_NPC,_Faction)
THEN
PROC_SetRelationToPlayers(_Faction,0);

IF
DialogEnded(_Dialog,_Id)
AND
DB_HostileToAllPlayersAfterDialog(_NPC,_Id)
THEN
NOT DB_HostileToAllPlayersAfterDialog(_NPC,_Id);
//END_REGION

//REGION Res, Heal, and remove statuses from a player

PROC
PROC_CharacterFullRestore((CHARACTER)_Char)
THEN
Resurrect(_Char);
RemoveHarmfulStatuses(_Char);
SetHitpointsPercentage(_Char,100.0);
ResetCooldowns(_Char);

PROC
SetHitpointsPercentage((GUIDSTRING)_Char,(REAL)_Percentage,(STRING)_HealTypes,(INTEGER)_OnlyIfDiffers)
THEN
DB_NOOP(1);

PROC
SetHitpointsPercentage((GUIDSTRING)_Char,(REAL)_Percentage,(STRING)_HealTypes,0)
THEN
SetHitpointsPercentage(_Char,_Percentage,_HealTypes);

PROC
SetHitpointsPercentage((GUIDSTRING)_Char,(REAL)_Percentage,(STRING)_HealTypes,1)
AND
GetHitpointsPercentage(_Char,_CurPercentage)
AND
RealToInteger(_Percentage,_PercentageI)
AND
RealToInteger(_CurPercentage,_CurPercentageI)
AND
_PercentageI != _CurPercentageI
THEN
SetHitpointsPercentage(_Char,_Percentage,_HealTypes);

PROC
PROC_SetHitpointsPercentageMinimum((GUIDSTRING)_Char,(REAL)_Percentage)
AND
GetHitpointsPercentage(_Char,_CurrentHealth)
AND
_CurrentHealth < _Percentage
THEN
SetHitpointsPercentage(_Char,_Percentage);

PROC
PROC_SetHitpointsMinimum((GUIDSTRING)_Char,(INTEGER)_Hitpoints)
AND
GetHitpoints(_Char,_CurrentHealth)
AND
_CurrentHealth < _Hitpoints
THEN
SetHitpoints(_Char,_Hitpoints);

//END_REGION

//REGION Camera Shake around Player
PROC
PROC_ShakeCameraForTime((CHARACTER)_Char,(INTEGER)_Time, (EFFECTRESOURCE)_VFX)
THEN
PROC_ShakeCameraForTime(_Char, _Time, _VFX, 0);

PROC
PROC_ShakeCameraForTime((CHARACTER)_Char,(INTEGER)_Time, (EFFECTRESOURCE)_VFX, (INTEGER)_IsRealtime)
AND
GetUUID(_Char,_UUID)
AND
Concatenate("CameraShake_",_UUID,_ID)
THEN
PROC_LoopEffect(_VFX,_Char,_ID,"__ANY__","");
PROC_ShakeCameraForTime_StartTimer(_Char, _Time, _IsRealtime);

PROC
PROC_ShakeCameraForTime_StartTimer((CHARACTER)_Char, (INTEGER)_Time, 0)
THEN
ObjectTimerLaunch(_Char,"Timer_LoopCameraShakeHelper",_Time);

PROC
PROC_ShakeCameraForTime_StartTimer((CHARACTER)_Char, (INTEGER)_Time, 1)
THEN
RealtimeObjectTimerLaunch(_Char,"Timer_LoopCameraShakeHelper",_Time);

IF
ObjectTimerFinished(_Char,"Timer_LoopCameraShakeHelper")
AND
GetUUID(_Char,_UUID)
AND
Concatenate("CameraShake_",_UUID,_ID)
THEN
PROC_StopLoopEffect(_Char,_ID);

PROC
PROC_CameraShakeAroundObject((GUIDSTRING)_Object,(INTEGER)_Duration,(REAL)_Radius)
THEN
PROC_CameraShakeAroundObject(_Object,_Duration,_Radius,VFX_Script_Generic_Camera_Shake_01_492bfa46-eafa-fe77-d9db-c5ede8175a6f);

PROC
PROC_CameraShakeAroundObject((GUIDSTRING)_Object,(INTEGER)_Duration,(REAL)_Radius, (EFFECTRESOURCE)_VFX)
AND
DB_Players(_Player)
AND
GetDistanceTo(_Player,_Object,_Dist)
AND
_Dist <= _Radius
THEN
PlayEffect(_Player,_VFX);
ObjectTimerCancel(_Player,"ShakeCameraOn_");
ObjectTimerLaunch(_Player,"ShakeCameraOn_",500);
DB_CameraShakeAroundObject(_Object,_Duration,_Radius);


IF
ObjectTimerFinished((CHARACTER)_Player,"ShakeCameraOn_")
AND
DB_CameraShakeAroundObject(_Object,_Duration,_Radius)
AND
IntegerSubtract(_Duration,500,_Dif)
AND
_Dif >= 0
THEN
NOT DB_CameraShakeAroundObject(_Object,_Duration,_Radius);
PROC_CameraShakeAroundObject(_Object,_Dif,_Radius);

IF
ObjectTimerFinished((CHARACTER)_Player,"ShakeCameraOn_")
AND
DB_CameraShakeAroundObject(_Object,_Duration,_Radius)
AND
IntegerSubtract(_Duration,200,_Dif)
AND
_Dif < 0.0
THEN
NOT DB_CameraShakeAroundObject(_Object,_Duration,_Radius);

//END_REGION

//REGION Flags that need to be propagated to Avatars controlling the same character & require attitude changes.
IF
FlagSet(_Flag, _Speaker, _ID)
AND
DB_ORI_AvatarFlag(_Flag)
AND
IsCharacter(_Speaker, 1)
AND
NOT DB_Avatars((CHARACTER)_Speaker)
THEN
ClearFlag(_Flag, _Speaker, _ID);

IF
FlagSet(_Flag, _Speaker, _ID)
AND
DB_ORI_AvatarFlag(_Flag)
AND
IsCharacter(_Speaker, 1)
AND
NOT DB_Avatars((CHARACTER)_Speaker)
AND
GetReservedUserID(_Speaker, _UserID)
AND
DB_Avatars(_Avatar)
AND
GetReservedUserID(_Avatar, _UserID)
THEN
SetFlag(_Flag, _Avatar, _ID);

IF
DB_ORI_ApprovalChangeFlag((FLAG)_Flag, (CHARACTER)_Origin, (INTEGER)_Attitude)
THEN
DB_ORI_AvatarFlag(_Flag);

IF
FlagSet(_Flag, _Avatar, _ID)
AND
DB_ORI_ApprovalChangeFlag(_Flag, _Origin, _Attitude)
AND
IsCharacter(_Avatar, 1)
AND
DB_Avatars((CHARACTER)_Avatar)
AND
ChangeApprovalRating((CHARACTER)_Origin, (CHARACTER)_Avatar, 0, (INTEGER)_Attitude,_)
THEN
DB_NOOP(1);

//END_REGION

//REGION PurgeQueue from outside Osiris
IF
EntityEvent((CHARACTER)_Char,"GEN_PurgeQueue")
THEN
PROC_ClearStoryMove(_Char);
//END_REGION

//REGION Do Knockdown fall / getup Animation
IF
EntityEvent((CHARACTER)_Char,"GEN_FallAndGetUp")
THEN
PlayAnimation(_Char,ANIMATION_STAT_KO_01_Start_789613f0-1c2a-4e63-9555-a964c6cabe98,"Play_Anim_knockdown_getup");

IF
EntityEvent((CHARACTER)_Char,"Play_Anim_knockdown_getup")
THEN
PlayAnimation(_Char,ANIMATION_STAT_KO_01_End_f53629c3-7632-4306-9102-a96624e5c084);

//END_REGION

//REGION Do Knockdown fall / knockdown loop Animation
IF
EntityEvent((CHARACTER)_Char,"GEN_FallAndLie")
THEN
PlayAnimation(_Char,ANIMATION_STAT_KO_01_End_f53629c3-7632-4306-9102-a96624e5c084,"Play_Anim_knockdown_loop");

IF
EntityEvent((CHARACTER)_Char,"Play_Anim_knockdown_loop")
THEN
PROC_PlayLoopingAnimation(_Char,(ANIMATION)NULL_00000000-0000-0000-0000-000000000000,(ANIMATION)ANIMATION_STAT_KO_01_Loop_22e5dd51-694a-42fd-a709-2b2dddfed049,(ANIMATION)NULL_00000000-0000-0000-0000-000000000000);

IF
EntityEvent((CHARACTER)_Char,"Stop_Anim_knockdown_loop")
THEN
StopAnimation((CHARACTER)_Char, 0);

//END_REGION

//REGION Is Available to

QRY
QRY_IsAvailableTo((CHARACTER)_Char,(CHARACTER)_Target)
AND
QRY_SpeakerIsAvailable(_Char)
AND
QRY_SpeakerIsAvailable(_Target)
AND
CanSee(_Char,_Target,1)
THEN
DB_NOOP(1);

//END_REGION

//REGION Animation testing
IF
TextEvent("LoopAnimTest")
AND
GetHostCharacter(_Player)
AND
GetTextEventParamUUID(1,(ANIMATION)_AnimName)
THEN
PROC_PlayLoopingAnimation(_Player,(ANIMATION)NULL_00000000-0000-0000-0000-000000000000,(ANIMATION)_AnimName,(ANIMATION)NULL_00000000-0000-0000-0000-000000000000);

IF
TextEvent("AnimTest")
AND
GetHostCharacter(_Player)
AND
GetTextEventParamInteger(1,0)
THEN
PurgeOsirisQueue(_Player);

IF
TextEvent("AnimTest")
AND
GetHostCharacter(_Player)
AND
GetTextEventParamInteger(1,0)
AND
DB_AnimTestLoopingAnimation(_Player,_AnimName)
THEN
NOT DB_AnimTestLoopingAnimation(_Player,_AnimName);

// oe animtest animation_name 
IF
TextEvent("AnimTest")
AND
GetHostCharacter((CHARACTER)_Player)
AND
GetTextEventParamUUID(1,(ANIMATION)_AnimName)
AND
NOT GetTextEventParamInteger(2,_)
THEN
PlayAnimation(_Player,_AnimName);

IF
TextEvent("AnimTest")
AND
GetHostCharacter((CHARACTER)_Player)
AND
GetTextEventParamUUID(1,(ANIMATION)_AnimName)
AND
GetTextEventParamInteger(2,1)
THEN
PlayAnimation(_Player,_AnimName);


IF
TextEvent("AnimTest")
AND
GetHostCharacter((CHARACTER)_Player)
AND
GetTextEventParamUUID(1,(ANIMATION)_AnimName)
AND
GetTextEventParamInteger(2,-1)
THEN
PlayAnimation(_Player,_AnimName,"AnimTest_PlayLoopingAnim");
DB_AnimTestLoopingAnimation(_Player,_AnimName);

IF
EntityEvent((CHARACTER)_Player,"AnimTest_PlayLoopingAnim")
AND
DB_AnimTestLoopingAnimation(_Player,_AnimName)
THEN
PlayAnimation(_Player,_AnimName,"AnimTest_PlayLoopingAnim");


IF
TextEvent("AnimTest")
AND
GetHostCharacter((CHARACTER)_Player)
AND
GetTextEventParamUUID(1,(ANIMATION)_AnimName)
AND
GetTextEventParamInteger(2,0)
THEN
PurgeOsirisQueue(_Player);



IF
TextEvent("AnimTest")
AND
GetHostCharacter((CHARACTER)_Player)
AND
GetTextEventParamUUID(1,(ANIMATION)_AnimName)
AND
GetTextEventParamInteger(2,0)
AND
DB_AnimTestLoopingAnimation(_Player,_AnimName)
THEN
NOT DB_AnimTestLoopingAnimation(_Player,_AnimName);


//END_REGION

//REGION Movie test
IF
TextEvent("movie")
AND
GetTextEventParamString(1, _Movie)
AND
GetHostCharacter(_Player)
THEN
MoviePlay(_Player,_Movie, 0);
//END_REGION

//REGION FX testing

// oe animtest animation_name 
//REGION OneShot

IF
TextEvent("FxTest")
AND
GetHostCharacter((CHARACTER)_Player)
AND
GetTextEventParamUUID(1,_FxName)
AND
GetTextEventParamInteger(2,1)
THEN
PlayEffect(_Player,(EFFECTRESOURCE)_FxName);
//END_REGION

//REGION Looping FX
IF
TextEvent("FxTest")
AND
GetHostCharacter((CHARACTER)_Player)
AND
GetTextEventParamUUID(1,_FxName)
AND
GetTextEventParamInteger(2,-1)
THEN
PROC_LoopEffect((EFFECTRESOURCE)_FxName,_Player,"FxTest","__ANY__","Dummy_FX");

IF
TextEvent("FxTest")
AND
GetHostCharacter((CHARACTER)_Player)
AND
GetTextEventParamUUID(1,_FxName)
AND
GetTextEventParamString(2,_BoneName)
AND
GetTextEventParamInteger(3,-1)
THEN
PROC_LoopEffect((EFFECTRESOURCE)_FxName,_Player,"FxTest","__ANY__",_BoneName);

/////// 0 or STOP to stop looping

IF
TextEvent("FxTest")
AND
GetHostCharacter((CHARACTER)_Player)
AND
GetTextEventParamString(1,"Stop")
THEN
PROC_StopLoopEffect(_Player,"FxTest");

IF
TextEvent("FxTestStop")
AND
GetHostCharacter((CHARACTER)_Player)
THEN
PROC_StopLoopEffect(_Player,"FxTest");

//END_REGION

//REGION Debug set relation to players

IF
TextEvent("setplayerrelation")
AND
GetTextEventParamInteger(1,_Relation)
AND
GetDebugCharacter(_Character)
AND
GetFaction(_Character,_Faction)
THEN
PROC_SetRelationToPlayers(_Faction,_Relation);

//END_REGION

//END_REGION

//REGION Has any weapon equiped
QRY
QRY_HasAnyWeaponEquipped((CHARACTER)_Char)
AND
HasMeleeWeaponEquipped(_Char,"Any",_Melee)
AND
HasRangedWeaponEquipped(_Char,"Any",_Ranged)
AND
DB_LogicOr(_Melee,_Ranged,1)
THEN
DB_NOOP(1);
//END_REGION

//REGION Conditional Object Flag Setter
PROC
PROC_SetConditionalObjectFlag((GUIDSTRING)_Object,(FLAG)_Flag,(INTEGER)_Condition)
AND
_Condition == 0
THEN
ClearFlag((FLAG)_Flag, _Object, 0); // flagType: Object

PROC
PROC_SetConditionalObjectFlag((GUIDSTRING)_Object,(FLAG)_Flag,(INTEGER)_Condition)
AND
_Condition != 0
THEN
SetFlag((FLAG)_Flag, _Object, 0); // flagType: Object

PROC
PROC_SetConditionalGlobalFlag((FLAG)_Flag,(INTEGER)_Condition)
AND
_Condition == 0
THEN
ClearFlag((FLAG)_Flag, NULL_00000000-0000-0000-0000-000000000000, 0); // flagType: Global

PROC
PROC_SetConditionalGlobalFlag((FLAG)_Flag,(INTEGER)_Condition)
AND
_Condition != 0
THEN
SetFlag((FLAG)_Flag, NULL_00000000-0000-0000-0000-000000000000, 0); // flagType: Global

PROC
PROC_SetConditionalTag((GUIDSTRING)_Object,(TAG)_Tag,(INTEGER)_Condition)
AND
_Condition == 0
THEN
ClearTag(_Object, _Tag);

PROC
PROC_SetConditionalTag((GUIDSTRING)_Object,(TAG)_Tag,(INTEGER)_Condition)
AND
_Condition != 0
THEN
SetTag(_Object, _Tag);

QRY
QRY_SetConditionalObjectFlag((GUIDSTRING)_Object,(FLAG)_Flag,(INTEGER)_Condition)
AND
_Flag != NULL_00000000-0000-0000-0000-000000000000
THEN
PROC_SetConditionalObjectFlag(_Object,_Flag,_Condition);

QRY
QRY_SetConditionalGlobalFlag((FLAG)_Flag,(INTEGER)_Condition)
AND
_Flag != NULL_00000000-0000-0000-0000-000000000000
THEN
PROC_SetConditionalGlobalFlag(_Flag,_Condition);
//END_REGION

//REGION Minimalist Queries
QRY
QRY_IsEmptyDB((STRING)_DB,(INTEGER)_Size)
AND
SysCount(_DB,_Size,0)
THEN
DB_NOOP(1);

QRY
QRY_IsInRange((GUIDSTRING)_Source,(GUIDSTRING)_Target,(REAL)_Range)
AND
GetDistanceTo(_Source,_Target,_Dist)
AND
_Dist <= _Range
THEN
DB_NOOP(1);
//END_REGION

//REGION TeleportSmoke
PROC
PROC_TeleportSmoke((GUIDSTRING)_Object)
AND
GetPosition(_Object,_X,_Y,_Z)
THEN
DebugText(_Object, "Calling PROC_TeleportSmoke but the FX is missing");
PlayEffectAtPosition((EFFECTRESOURCE)VFX_Script_Stub_Poof_01_f0cf792a-0f74-d17e-ad0d-6052a6131416,_X,_Y,_Z);
//END_REGION

//REGION Remove Weapons

PROC
PROC_GLO_UnequipAllWeapons((CHARACTER)_Char)
AND
DB_GLO_WeaponSlots(_Slot)
AND
GetEquippedItem(_Char,_Slot,_Weapon)
THEN
Unequip(_Char,_Weapon);

PROC
PROC_GLO_DeleteAllWeapons((CHARACTER)_Char)
AND
DB_GLO_WeaponSlots(_Slot)
AND
GetEquippedItem(_Char,_Slot,_Weapon)
THEN
RequestDelete(_Weapon);

//END_REGION

//REGION Add characters within a trigger to the dialog

//DB_AddCharactersInTriggerToDialog((DIALOGRESOURCE)_Dialog,(TRIGGER)_Trigger,(INTEGER)_AddAfterStart,(INTEGER)_IgnoreCombat,(INTEGER)_IgnoreStatus,(INTEGER)_IncludeAllPartyMembers)
IF
DB_AddCharactersInTriggerToDialog((DIALOGRESOURCE)_Dialog,(TRIGGER)_Trigger,(INTEGER)_AddAfterStart)
THEN
DB_AddCharactersInTriggerToDialog(_Dialog,_Trigger, _AddAfterStart, 0, 0, 0);

IF
DB_AddCharactersInTriggerToDialog((DIALOGRESOURCE)_Dialog,(TRIGGER)_Trigger,(INTEGER)_AddAfterStart,(INTEGER)_IgnoreCombat)
THEN
DB_AddCharactersInTriggerToDialog(_Dialog,_Trigger, _AddAfterStart, _IgnoreCombat, 0, 0);

IF
DB_AddCharactersInTriggerToDialog((DIALOGRESOURCE)_Dialog,(TRIGGER)_Trigger,(INTEGER)_AddAfterStart,(INTEGER)_IgnoreCombat,(INTEGER)_IgnoreStatus)
THEN
DB_AddCharactersInTriggerToDialog(_Dialog,_Trigger, _AddAfterStart, _IgnoreCombat, _IgnoreStatus, 0);

//Remove
PROC
PROC_AddCharactersInTriggerToDialog_Clear((DIALOGRESOURCE)_Dialog,(TRIGGER)_Trigger)
AND
DB_AddCharactersInTriggerToDialog((DIALOGRESOURCE)_Dialog,(TRIGGER)_Trigger,(INTEGER)_AddAfterStart,(INTEGER)_IgnoreCombat,(INTEGER)_IgnoreStatus,(INTEGER)_IncludeAllPartyMembers)
THEN
NOT DB_AddCharactersInTriggerToDialog((DIALOGRESOURCE)_Dialog,(TRIGGER)_Trigger,(INTEGER)_AddAfterStart,(INTEGER)_IgnoreCombat,(INTEGER)_IgnoreStatus,(INTEGER)_IncludeAllPartyMembers);
NOT DB_AddCharactersInTriggerToDialog((DIALOGRESOURCE)_Dialog,(TRIGGER)_Trigger,(INTEGER)_AddAfterStart,(INTEGER)_IgnoreCombat,(INTEGER)_IgnoreStatus);
NOT DB_AddCharactersInTriggerToDialog((DIALOGRESOURCE)_Dialog,(TRIGGER)_Trigger,(INTEGER)_AddAfterStart,(INTEGER)_IgnoreCombat);

//Add on start
PROC
PROC_StartDialog_AddNearbySpeakersToDialog((DIALOGRESOURCE)_Dialog,(INTEGER)_Inst)
AND
DB_AddCharactersInTriggerToDialog(_Dialog,_Trigger, _AddAfterStart, _IgnoreCombat, _IgnoreStatus,_) 
AND
DB_PartyMembers(_Char)
AND
NOT DB_InteractiveDialogSpeaker(_Inst,_Char)
AND
IsInTrigger(_Char,_Trigger, 1)
AND
NOT QRY_ShouldNotAddCharacterInTriggerToDialog((CHARACTER)_Char,(DIALOGRESOURCE)_Dialog,(TRIGGER)_Trigger)
AND
NOT QRY_AddCharactersInTriggerToDialog_CanAddAfterStart(_Char, _AddAfterStart, _Trigger)
THEN
PROC_TryAddSpeakingActorFromTriggerToDialog(_Inst, _Char, _IgnoreCombat, _IgnoreStatus);

PROC
PROC_TryAddSpeakingActorFromTriggerToDialog((INTEGER)_Inst,(CHARACTER)_Speaker,(INTEGER)_IgnoreCombat, 0)
AND
QRY_SpeakerIsAvailable(_Speaker, _IgnoreCombat, 0)
THEN
PROC_DialogAddSpeakingActor(_Inst,_Speaker,1,1);
DB_Dialog_IncludedNearbySpeakers(_Inst,_Speaker);

PROC
PROC_TryAddSpeakingActorFromTriggerToDialog((INTEGER)_Inst,(CHARACTER)_Speaker,(INTEGER)_IgnoreCombat, 1)
AND
NOT DB_Downed(_Speaker)
AND
QRY_SpeakerIsAvailable(_Speaker, _IgnoreCombat, 1)
THEN
PROC_DialogAddSpeakingActor(_Inst,_Speaker,1,1);
DB_Dialog_IncludedNearbySpeakers(_Inst,_Speaker);

PROC
PROC_TryAddSpeakingActorFromTriggerToDialog((INTEGER)_Inst,(CHARACTER)_Speaker,(INTEGER)_IgnoreCombat, 1)
AND
DB_Downed(_Speaker)
AND
NOT DB_DialogEnding(_,_Inst)
AND
QRY_DownedSpeakerIsAvailable((GUIDSTRING)_Speaker, _IgnoreCombat)
AND
DB_DialogRequestCache_DialogInstance(_Dialog,_Inst)
AND
QRY_PrepForInteractiveDialog_IfInteractive(_Dialog,_Inst,_Speaker)
THEN
DialogAddActorAtReservedSlot(_Inst,_Speaker,1,0,1);
PROC_DialogRequestCache_MakeSpeakerLists_Evaluate(_Dialog,_Inst,_Speaker);
DB_Dialog_IncludedNearbySpeakers(_Inst,_Speaker);

//QRY_SpeakerIsAvailableCheckDowned((GUIDSTRING)_Speaker, (INTEGER)_IgnoreCombat)
QRY
QRY_DownedSpeakerIsAvailable((GUIDSTRING)_Speaker, 1)
AND
DB_Downed((CHARACTER)_Speaker)
AND
DB_ObjectIsDialogSoftLocked(_,_Speaker)
THEN
DB_NOOP(1);

QRY
QRY_DownedSpeakerIsAvailable((GUIDSTRING)_Speaker, 1)
AND
DB_Downed((CHARACTER)_Speaker)
AND
IsSpeakerReserved(_Speaker,0)
THEN
DB_NOOP(1);

QRY
QRY_DownedSpeakerIsAvailable((GUIDSTRING)_Speaker, 0)
AND
DB_Downed((CHARACTER)_Speaker)
AND
NOT DB_Is_InCombat(_Speaker, _)
AND
DB_ObjectIsDialogSoftLocked(_,_Speaker)
THEN
DB_NOOP(1);

QRY
QRY_DownedSpeakerIsAvailable((GUIDSTRING)_Speaker, 0)
AND
DB_Downed((CHARACTER)_Speaker)
AND
NOT DB_Is_InCombat(_Speaker, _)
AND
IsSpeakerReserved(_Speaker,0)
THEN
DB_NOOP(1);

QRY
QRY_DialogStarted_CheckPlayerForStopConditions_IgnoreDowned((INTEGER)_Inst,(CHARACTER)_Player)
AND
DB_DialogRequestCache_DialogInstance(_Dialog,_Inst)
AND
DB_AddCharactersInTriggerToDialog(_Dialog,_, _, _, 1, _) 
THEN
DB_NOOP(1);

//Add after start
IF
DB_DialogName(_Dialog,_Id)
AND
NOT DB_DialogEnding(_Dialog,_Id)
AND
DB_AddCharactersInTriggerToDialog(_Dialog, (TRIGGER)_Trigger, 1, _, _, _)
AND
DB_PartyMembers(_Char)
AND
DB_InRegion((CHARACTER)_Char, _Trigger)
AND
NOT QRY_ShouldNotAddCharacterInTriggerToDialog((CHARACTER)_Char,(DIALOGRESOURCE)_Dialog,(TRIGGER)_Trigger)
THEN
PROC_DialogAddListeningActor(_Id,_Char);
DB_Dialog_IncludedNearbySpeakers((INTEGER)_Id,(CHARACTER)_Char);

QRY
QRY_AddCharactersInTriggerToDialog_CanAddAfterStart((CHARACTER)_Char, (INTEGER)_AddAfterStart, (TRIGGER)_Trigger)
AND
DB_Avatars(_Char)
AND
_AddAfterStart == 1
AND
DB_ActivePartyTriggers(_, _Trigger, _)
THEN
DB_NOOP(1);

//Conditions for not adding character to dialog
//Defeated
QRY
QRY_ShouldNotAddCharacterInTriggerToDialog((CHARACTER)_Character,(DIALOGRESOURCE)_Dialog,(TRIGGER)_Trigger)
AND
DB_AddCharactersInTriggerToDialog(_Dialog,_Trigger,_,_,_IgnoreStatus,_)
AND
QRY_ShouldIgnoreDownedStatus(_Character, _IgnoreStatus)
THEN
DB_NOOP(1);

QRY
QRY_ShouldIgnoreDownedStatus((CHARACTER)_Character, 1)
AND
NOT DB_Downed(_Character)
AND
DB_Defeated(_Character)
THEN
DB_NOOP(1);

QRY
QRY_ShouldIgnoreDownedStatus((CHARACTER)_Character, 0)
AND
DB_Defeated(_Character)
THEN
DB_NOOP(1);

//Not a player (include only players)
QRY
QRY_ShouldNotAddCharacterInTriggerToDialog((CHARACTER)_Character,(DIALOGRESOURCE)_Dialog,(TRIGGER)_Trigger)
AND
DB_AddCharactersInTriggerToDialog(_Dialog,_Trigger,_,_,_,0)
AND
NOT DB_Players(_Character)
THEN
DB_NOOP(1);

//Can't talk
QRY
QRY_ShouldNotAddCharacterInTriggerToDialog((CHARACTER)_Character,(DIALOGRESOURCE)_Dialog,(TRIGGER)_Trigger)
AND
DB_AddCharactersInTriggerToDialog(_Dialog,_Trigger,_,0,0,_)
AND
DB_CantTalk(_Character)
THEN
DB_NOOP(1);

//Can't talk, ignoring combat
QRY
QRY_ShouldNotAddCharacterInTriggerToDialog((CHARACTER)_Character,(DIALOGRESOURCE)_Dialog,(TRIGGER)_Trigger)
AND
DB_AddCharactersInTriggerToDialog(_Dialog,_Trigger,_,1,0,_)
AND
DB_CantTalk_IgnoreCombat(_Character)
THEN
DB_NOOP(1);

//Can't talk, ignoring status
QRY
QRY_ShouldNotAddCharacterInTriggerToDialog((CHARACTER)_Character,(DIALOGRESOURCE)_Dialog,(TRIGGER)_Trigger)
AND
DB_AddCharactersInTriggerToDialog(_Dialog,_Trigger,_,0,1,_)
AND
DB_CantTalk_IgnoreStatuses(_Character)
AND
QRY_ShouldIgnoreDownedStatus(_Character, 1)
THEN
DB_NOOP(1);

//Can't talk, ignoring combat and status
QRY
QRY_ShouldNotAddCharacterInTriggerToDialog((CHARACTER)_Character,(DIALOGRESOURCE)_Dialog,(TRIGGER)_Trigger)
AND
DB_AddCharactersInTriggerToDialog(_Dialog,_Trigger,_,1,1,_)
AND
DB_CantTalk_IgnoreStatusesCombat(_Character)
AND
QRY_ShouldIgnoreDownedStatus(_Character, 1)
THEN
DB_NOOP(1);

//Exclude hidden characters
QRY
QRY_ShouldNotAddCharacterInTriggerToDialog((CHARACTER)_Character,(DIALOGRESOURCE)_Dialog,(TRIGGER)_Trigger)
AND
DB_AddCharactersInTriggerToDialog(_Dialog,_Trigger,_,_,_,_)
AND
DB_AddCharactersInTriggerToDialog_IgnoreHidden(_Dialog)
AND
DB_HiddenCharacters(_Character, _)
THEN
DB_NOOP(1);
//END_REGION

//REGION Replace one-time use dialog flag into a proc call (for flags used to trigger actions)
// DB_OneTimeEventFlag

PROC
PROC_OneTimeEventFlag((FLAG)_Flag)
THEN
DB_NOOP(1);

PROC
PROC_OneTimeEventFlag((GUIDSTRING)_Object,(FLAG)_Flag)
THEN
DB_NOOP(1);

PROC
PROC_OneTimeEventFlag((GUIDSTRING)_Object,(FLAG)_Flag,(INTEGER)_DialogInst)
THEN
DB_NOOP(1);

IF
FlagSet((FLAG)_Flag, _Object, _DlgInst) // flagType: Object
AND
DB_OneTimeEventFlag((FLAG)_Flag)
THEN
ClearFlag((FLAG)_Flag, _Object); // flagType: Object
PROC_OneTimeEventFlag((FLAG)_Flag);
PROC_OneTimeEventFlag(_Object,(FLAG)_Flag);
PROC_OneTimeEventFlag(_Object,(FLAG)_Flag,_DlgInst);
/*
IF
FlagSet((FLAG)_Flag, _, _) // flagType: Global
AND
DB_OneTimeEventFlag((FLAG)_Flag)
THEN
ClearFlag((FLAG)_Flag, NULL_00000000-0000-0000-0000-000000000000, 0); // flagType: Global
PROC_OneTimeEventFlag((FLAG)_Flag);*/
//END_REGION

//REGION Flags set in dialog that should trigger after dialog end
// DB_FlagReactionAfterDialog((FLAG)_Dialog,(DIALOGRESOURCE)_Flag)
// DB_FlagReactionAfterDialog((GUIDSTRING)_Object,(FLAG)_Dialog,(DIALOGRESOURCE)_Dialog)
IF
FlagSet((FLAG)_Flag, _Object, _DialogID) // flagType: Object
AND
DB_DialogName(_Dialog,_DialogID)
AND
DB_FlagReactionAfterDialog((FLAG)_Flag,_Dialog)
THEN
DB_FlagReactionAfterDialog_Prepare(_Object,(FLAG)_Flag,_Dialog,_DialogID);

IF
FlagSet((FLAG)_Flag, _Object, _DialogID) // flagType: Object
AND
DB_DialogName(_Dialog,_DialogID)
AND
DB_FlagReactionAfterDialog(_Object,(FLAG)_Flag,_Dialog)
THEN
DB_FlagReactionAfterDialog_Prepare(_Object,(FLAG)_Flag,_Dialog,_DialogID);

IF
FlagCleared((FLAG)_Flag, _Object, _DialogID) // flagType: Object
AND
DB_FlagReactionAfterDialog_Prepare(_Object,(FLAG)_Flag,_Dialog,_DialogID)
THEN
NOT DB_FlagReactionAfterDialog_Prepare(_Object,(FLAG)_Flag,_Dialog,_DialogID);

IF
AutomatedDialogEnded(_,_DialogID)
AND
DB_FlagReactionAfterDialog_Prepare(_Object,(FLAG)_Flag,_Dialog,_DialogID)
THEN
NOT DB_FlagReactionAfterDialog_Prepare(_Object,(FLAG)_Flag,_Dialog,_DialogID);
PROC_FlagReactionAfterDialog(_Object,(FLAG)_Flag,_Dialog,_DialogID);

IF
DialogEnded(_,_DialogID)
AND
DB_FlagReactionAfterDialog_Prepare(_Object,(FLAG)_Flag,_Dialog,_DialogID)
THEN
NOT DB_FlagReactionAfterDialog_Prepare(_Object,(FLAG)_Flag,_Dialog,_DialogID);
PROC_FlagReactionAfterDialog(_Object,(FLAG)_Flag,_Dialog,_DialogID);

PROC
PROC_FlagReactionAfterDialog((GUIDSTRING)_Object,(FLAG)_Flag,(DIALOGRESOURCE)_Dialog,(INTEGER)_DialogID)
THEN
PROC_FlagReactionAfterDialog((GUIDSTRING)_Object,(FLAG)_Flag,(DIALOGRESOURCE)_Dialog);

PROC
PROC_FlagReactionAfterDialog((GUIDSTRING)_Object,(FLAG)_Flag,(DIALOGRESOURCE)_Dialog)
THEN
PROC_FlagReactionAfterDialog((GUIDSTRING)_Object,(FLAG)_Flag);

PROC
PROC_FlagReactionAfterDialog((GUIDSTRING)_Object,(FLAG)_Flag)
THEN
DB_NOOP(1);


// DB_GlobalFlagReactionAfterDialog((DIALOGGUID)_Dialog,(STRING)_Flag)
IF
FlagSet((FLAG)_Flag, _, _) // flagType: Global
AND
DB_GlobalFlagReactionAfterDialog((FLAG)_Flag,_Dialog)
AND
DB_DialogName(_Dialog,_DialogID)
THEN
DB_GlobalFlagReactionAfterDialog_Prepare((FLAG)_Flag,_Dialog,_DialogID);

IF
AutomatedDialogEnded(_,_DialogID)
AND
DB_GlobalFlagReactionAfterDialog_Prepare((FLAG)_Flag,_Dialog,_DialogID)
THEN
NOT DB_GlobalFlagReactionAfterDialog_Prepare((FLAG)_Flag,_Dialog,_DialogID);
PROC_GlobalFlagReactionAfterDialog((FLAG)_Flag,_Dialog,_DialogID);

IF
DialogEnded(_,_DialogID)
AND
DB_GlobalFlagReactionAfterDialog_Prepare((FLAG)_Flag,_Dialog,_DialogID)
THEN
NOT DB_GlobalFlagReactionAfterDialog_Prepare((FLAG)_Flag,_Dialog,_DialogID);
PROC_GlobalFlagReactionAfterDialog((FLAG)_Flag,_Dialog,_DialogID);

PROC
PROC_GlobalFlagReactionAfterDialog((FLAG)_Flag,(DIALOGRESOURCE)_Dialog,(INTEGER)_DialogID)
THEN
PROC_GlobalFlagReactionAfterDialog((FLAG)_Flag,(DIALOGRESOURCE)_Dialog);

PROC
PROC_GlobalFlagReactionAfterDialog((FLAG)_Flag,(DIALOGRESOURCE)_Dialog)
THEN
PROC_GlobalFlagReactionAfterDialog((FLAG)_Flag);

PROC
PROC_GlobalFlagReactionAfterDialog((FLAG)_Flag)
THEN
DB_NOOP(1);
//END_REGION

//REGION StartDialog With Visible Tagged Player 

QRY
QRY_StartDialog_WithVisibleTag((CHARACTER)_NPC,(CHARACTER)_Player,(DIALOGRESOURCE)_Dialog,(TAG)_MainTag,(TAG)_FallBackTag,(INTEGER)_AddOtherPlayersToDialog)
AND
NOT DB_QRY_StartDialogWithVisibleTag(1)
AND
IsTagged(_Player,_MainTag,1)
AND
QRY_SpeakerIsAvailableAndInDialogRange(_NPC,_Player)
AND
QRY_StartDialog_Fixed(_Dialog,_NPC,_Player)
THEN
DB_QRY_StartDialogWithVisibleTag(1);

QRY
QRY_StartDialog_WithVisibleTag((CHARACTER)_NPC,(CHARACTER)_Player,(DIALOGRESOURCE)_Dialog,(TAG)_MainTag,(TAG)_FallBackTag,(INTEGER)_AddOtherPlayersToDialog)
AND
NOT DB_QRY_StartDialogWithVisibleTag(1)
AND
IsTagged(_Player,_MainTag,0)
AND
DB_Players(_OtherPlayers)
AND
IsTagged(_OtherPlayers,_MainTag,1)
AND
QRY_SpeakerIsAvailableAndInDialogRange(_NPC,_OtherPlayers)
AND
QRY_StartDialog_Fixed(_Dialog,_NPC,_OtherPlayers)
THEN
DB_QRY_StartDialogWithVisibleTag(1);

QRY
QRY_StartDialog_WithVisibleTag((CHARACTER)_NPC,(CHARACTER)_Player,(DIALOGRESOURCE)_Dialog,(TAG)_MainTag,(TAG)_FallBackTag,(INTEGER)_AddOtherPlayersToDialog)
AND
NOT DB_QRY_StartDialogWithVisibleTag(1)
AND
IsTagged(_Player,_FallBackTag,1)
AND
QRY_SpeakerIsAvailableAndInDialogRange(_NPC,_Player)
AND
QRY_StartDialog_Fixed(_Dialog,_NPC,_Player)
THEN
DB_QRY_StartDialogWithVisibleTag(1);

QRY
QRY_StartDialog_WithVisibleTag((CHARACTER)_NPC,(CHARACTER)_Player,(DIALOGRESOURCE)_Dialog,(TAG)_MainTag,(TAG)_FallBackTag,(INTEGER)_AddOtherPlayersToDialog)
AND
NOT DB_QRY_StartDialogWithVisibleTag(1)
AND
IsTagged(_Player,_FallBackTag,0)
AND
DB_Players(_OtherPlayers)
AND
IsTagged(_OtherPlayers,_FallBackTag,1)
AND
QRY_SpeakerIsAvailableAndInDialogRange(_NPC,_OtherPlayers)
AND
QRY_StartDialog_Fixed(_Dialog,_NPC,_OtherPlayers)
THEN
DB_QRY_StartDialogWithVisibleTag(1);

QRY
QRY_StartDialog_WithVisibleTag((CHARACTER)_NPC,(CHARACTER)_Player,(DIALOGRESOURCE)_Dialog,(TAG)_MainTag,(TAG)_FallBackTag,(INTEGER)_AddOtherPlayersToDialog)
AND
NOT DB_QRY_StartDialogWithVisibleTag(1)
AND
QRY_SpeakerIsAvailableAndInDialogRange(_NPC,_Player)
AND
QRY_StartDialog(_Dialog,_NPC,_Player)
THEN
DB_QRY_StartDialogWithVisibleTag(1);

QRY
QRY_StartDialog_WithVisibleTag((CHARACTER)_NPC,(CHARACTER)_Player,(DIALOGRESOURCE)_Dialog,(TAG)_MainTag,(TAG)_FallBackTag,(INTEGER)_AddOtherPlayersToDialog)
AND
DB_QRY_StartDialogWithVisibleTag(1)
THEN
DB_QRY_StartDialogWithVisibleTag_AddPlayers(_NPC,_Player,_Dialog);

QRY
QRY_StartDialog_WithVisibleTag((CHARACTER)_NPC,(CHARACTER)_Player,(DIALOGRESOURCE)_Dialog,(TAG)_MainTag,(TAG)_FallBackTag,(INTEGER)_AddOtherPlayersToDialog)
AND
DB_QRY_StartDialogWithVisibleTag(1)
THEN
NOT DB_QRY_StartDialogWithVisibleTag(1);

PROC
PROC_StartDialog_AddExtraSpeakers((DIALOGRESOURCE)_Dialog,(INTEGER)_ID)
AND
DB_QRY_StartDialogWithVisibleTag_AddPlayers(_NPC,_Player,_Dialog)
AND
DB_Players(_Players)
AND
QRY_SpeakerIsAvailable(_Players)
AND
CanSee(_NPC,_Players,1)
THEN
PROC_DialogAddSpeakingActor(_ID,_Players);

PROC
PROC_StartDialog_AddExtraSpeakers((DIALOGRESOURCE)_Dialog,(INTEGER)_ID)
AND
DB_QRY_StartDialogWithVisibleTag_AddPlayers(_NPC,_Player,_Dialog)
THEN
NOT DB_QRY_StartDialogWithVisibleTag_AddPlayers(_NPC,_Player,_Dialog);

//END_REGION

//REGION Safe teleport for characters: teleport and flush/stop existing commands
PROC
PROC_Helper_SafeTeleportTo((CHARACTER)_Char,(GUIDSTRING)_Dest)
THEN
PROC_Helper_SafeTeleportTo(_Char,_Dest,"",1,1,1);

PROC
PROC_Helper_SafeTeleportTo((CHARACTER)_Char,(GUIDSTRING)_Dest,(STRING)_Event,(INTEGER)_TeleportLinkedCharacters)
THEN
PROC_Helper_SafeTeleportTo(_Char,_Dest,_Event,_TeleportLinkedCharacters,1,1);

PROC
PROC_Helper_SafeTeleportTo((CHARACTER)_Char,(GUIDSTRING)_Dest,(STRING)_Event,(INTEGER)_TeleportLinkedCharacters,(INTEGER)_TeleportPartyFollowers,(INTEGER)_TeleportSummons)
THEN
TeleportTo(_Char,_Dest,_Event,_TeleportLinkedCharacters,_TeleportPartyFollowers,_TeleportSummons);
FlushOsirisQueue(_Char);
LeaveCombat(_Char);
SetEntityEvent(_Char,"ClearPeaceReturn", 1);
// Clear ongoing animations
StopAnimation(_Char, 0);

PROC
PROC_TeleportToSafePosition((CHARACTER)_Player,(REAL)_X,(REAL)_Y,(REAL)_Z)
THEN
PROC_TeleportToSafePosition(_Player, _X,_Y,_Z,"",1,0,1,0,1);

PROC
PROC_TeleportToSafePosition((CHARACTER)_Player,(REAL)_X,(REAL)_Y,(REAL)_Z,(STRING)_Event,(INTEGER)_TeleportLinkedCharacters,(INTEGER)_TeleportPartyFollowers,(INTEGER)_TeleportSummons,(INTEGER)_LeaveCombat,(INTEGER)_SnapToGround)
AND
FindValidPosition(_X,_Y,_Z,15.0,_Player,1,_SafeX,_SafeY,_SafeZ)
THEN
DB_TeleportToSafePosition("Succes!");
TeleportToPosition(_Player,_SafeX,_SafeY,_SafeZ,_Event,_TeleportLinkedCharacters,_TeleportPartyFollowers,_TeleportSummons,_LeaveCombat,_SnapToGround);

PROC
PROC_TeleportToSafePosition((CHARACTER)_Player,(REAL)_X,(REAL)_Y,(REAL)_Z,(STRING)_Event,(INTEGER)_TeleportLinkedCharacters,(INTEGER)_TeleportPartyFollowers,(INTEGER)_TeleportSummons,(INTEGER)_LeaveCombat,(INTEGER)_SnapToGround)
AND
NOT DB_TeleportToSafePosition("Succes!")
THEN
TeleportToPosition(_Player,_X,_Y,_Z,_Event,_TeleportLinkedCharacters,_TeleportPartyFollowers,_TeleportSummons,_LeaveCombat,_SnapToGround);

PROC
PROC_TeleportToSafePosition((CHARACTER)_Player,(REAL)_X,(REAL)_Y,(REAL)_Z,(STRING)_Event,(INTEGER)_TeleportLinkedCharacters,(INTEGER)_TeleportPartyFollowers,(INTEGER)_TeleportSummons,(INTEGER)_LeaveCombat,(INTEGER)_SnapToGround)
THEN
NOT DB_TeleportToSafePosition("Succes!");
//END_REGION

//REGION Teleport In/Out script helpers

IF
EntityEvent((CHARACTER)_Char,"GEN_Teleport_In")
THEN
SetOnStage(_Char,1);
PlayAnimation(_Char,ANIMATION_SCPT_Teleport_In_01_00000000-0000-0000-0000-000000000000);


IF
EntityEvent((CHARACTER)_Char,"GEN_Teleport_Out")
THEN
PlayAnimation(_Char,ANIMATION_SCPT_Teleport_Out_01_00000000-0000-0000-0000-000000000000,"GEN_GoOffStage");


//END_REGION

//REGION Sign function
QRY
QRY_IntegerSign((INTEGER)_Value)
AND
DB_IntegerSign(_Result)
THEN
NOT DB_IntegerSign(_Result);

QRY
QRY_IntegerSign((INTEGER)_Value)
AND
_Value < 0
THEN
DB_IntegerSign(-1);

QRY
QRY_IntegerSign((INTEGER)_Value)
AND
_Value == 0
THEN
DB_IntegerSign(0);

QRY
QRY_IntegerSign((INTEGER)_Value)
AND
_Value > 0
THEN
DB_IntegerSign(0);
//END_REGION

//REGION Absolute value
QRY
QRY_IntegerAbs((INTEGER)_)
AND
DB_QRYRTN_IntegerAbs(_Value)
THEN
NOT DB_QRYRTN_IntegerAbs(_Value);

QRY
QRY_IntegerAbs((INTEGER)_Value)
AND
_Value >= 0
THEN
DB_QRYRTN_IntegerAbs(_Value);

QRY
QRY_IntegerAbs((INTEGER)_Value)
AND
_Value < 0
AND
IntegerProduct(_Value, -1, _Absolute)
THEN
DB_QRYRTN_IntegerAbs(_Absolute);

QRY
QRY_RealAbs((REAL)_)
AND
DB_QRYRTN_RealAbs(_Value)
THEN
NOT DB_QRYRTN_RealAbs(_Value);

QRY
QRY_RealAbs((REAL)_Value)
AND
_Value >= 0.0
THEN
DB_QRYRTN_RealAbs(_Value);

QRY
QRY_RealAbs((REAL)_Value)
AND
_Value < 0
AND
RealProduct(_Value, -1.0, _Absolute)
THEN
DB_QRYRTN_RealAbs(_Absolute);

//END_REGION

//REGION Angle normalisation
// Supports ranges -360 to postive infinite and normalises the angle to a postive angle.
QRY
QRY_NormaliseAngle((REAL)_Angle)
AND
DB_QRYRTN_NormaliseAngle((REAL)_Result)
THEN
NOT DB_QRYRTN_NormaliseAngle(_Result);

QRY
QRY_NormaliseAngle((REAL)_Angle)
AND
_Angle < -0.01 // prevent rounding errors from returning 360 instead of 0
AND
RealSum(_Angle, 360.0, _NormalisedAngle)
THEN
DB_QRYRTN_NormaliseAngle(_NormalisedAngle);

QRY
QRY_NormaliseAngle((REAL)_Angle)
AND
_Angle >= -0.01
AND
RealDivide(_Angle, 360.0, _Times360)
AND
RealToInteger(_Times360, _Times360ToRound)
AND
IntegerToReal(_Times360ToRound, _Times360Rounded)
AND
RealProduct(_Times360Rounded, 360.0, _ToSubtract)
AND
RealSubtract(_Angle, _ToSubtract, _NormalisedAngle)
THEN
DB_QRYRTN_NormaliseAngle(_NormalisedAngle);
//END_REGION

//REGION Clear a party flag on all players and potential companions
//NOTE: This call will not work for characters that are not currently loaded,
//e.g. local characters currently in another level that you could re-recruit.

IF
CharacterJoinedParty(_Character)
THEN
DB_IsOrWasInParty(_Character);

PROC
PROC_PurgeLevelPartyFlag((FLAG)_Flagname)
AND
DB_IsOrWasInParty(_Character)
AND
Exists(_Character, 1)
THEN
ClearFlag((FLAG)_Flagname, _Character, 0);
//END_REGION


//REGION Generic Remove From Dialog

IF
FlagSet(GEN_RemoveFromDialog_f8be170a-8fec-b106-c6ab-204f0b917828, _Char, _Id) // flagType: Object
AND
DialogRemoveActorFromDialog(_Id,_Char,1)
THEN
DB_NOOP(1);

//END_REGION

//REGION Party Region Progress
IF
DB_PartyProgress_Trigger((TRIGGER)_Trigger,(FLAG)_GlobalFlag)
THEN
PROC_TriggerRegisterForPlayers(_Trigger);

IF
EnteredTrigger(_Player,_Trigger)
AND
DB_Players(_Player)
AND
DB_PartyProgress_Trigger(_Trigger,(FLAG)_GlobalFlag)
THEN
NOT DB_PartyProgress_Trigger(_Trigger,(FLAG)_GlobalFlag);
SetFlag(_GlobalFlag,NULL_00000000-0000-0000-0000-000000000000,0);
//END_REGION

//REGION Party Level Reached Flags
IF
LeveledUp(_Char)
AND
DB_Players(_Char)
AND
GetLevel(_Char, _Level)
AND
DB_PartyProgress_Level((INTEGER)_MinLevel,(FLAG)_GlobalFlag)
AND
_Level >= _MinLevel
AND
NOT DB_GlobalFlag(_GlobalFlag)
THEN
SetFlag(_GlobalFlag, NULL_00000000-0000-0000-0000-000000000000);
//END_REGION

//REGION Play Reveal effect

PROC
PROC_PlayPerceptionRevealEffect((GUIDSTRING)_Obj, (STRING)_ID)
THEN
PROC_PlayPerceptionRevealEffect(_Obj, _ID, 3000);

PROC
PROC_PlayPerceptionRevealEffect((GUIDSTRING)_Obj, (STRING)_ID, (INTEGER)_Time)
AND
DB_CurrentLevel(_Level)
THEN
PROC_PlayPerceptionRevealEffect(_Obj, _ID, _Time, _Level);

PROC
PROC_PlayPerceptionRevealEffect((GUIDSTRING)_Obj, (STRING)_ID, (INTEGER)_Time, (STRING)_Level)
THEN
PROC_PlayPerceptionRevealEffect(_Obj, _ID, _Time, _Level, "");

PROC
PROC_PlayPerceptionRevealEffect((GUIDSTRING)_Obj, (STRING)_ID, (INTEGER)_Time, (STRING)_Level, (STRING)_Bone)
THEN
PROC_PlayPerceptionRevealEffect(_Obj, _ID, _Time, _Level, "", 1.0);

PROC
PROC_PlayPerceptionRevealEffect((GUIDSTRING)_Obj, (STRING)_ID, (INTEGER)_Time, (STRING)_Level, (STRING)_Bone, (REAL)_Scale)
AND
NOT DB_PlayingPerceptionRevealEffect(_Obj, _ID)
THEN
PROC_LoopEffect(VFX_Script_Perception_Default_01_46bd169e-bbb5-a6fe-0fe7-97c64f620d5d, _Obj, _ID, _Level, _Bone, _Scale);
DB_PlayingPerceptionRevealEffect(_Obj, _ID);
RealtimeObjectTimerLaunch(_Obj,_ID,_Time);

IF
ObjectTimerFinished(_Obj,_ID)
AND
DB_PlayingPerceptionRevealEffect(_Obj, _ID)
THEN
NOT DB_PlayingPerceptionRevealEffect(_Obj, _ID);
PROC_StopLoopEffect(_Obj, _ID);

//END_REGION

//REGION Play Sound OE
IF
TextEvent("PlaySound")
AND
GetHostCharacter((CHARACTER)_Player)
AND
GetTextEventParamString(1,_Event)
THEN
PlaySound(_Player,_Event);
//END_REGION 

//REGION Dialog Statusses
IF
FlagSet((FLAG)_StatusSetter, _Character, _) // flagType: Object
AND
DB_DialogStatusSetter((FLAG)_StatusSetter,(FLAG)_,_Status)
THEN
ApplyStatus(_Character,_Status,1.0,1,NULL_00000000-0000-0000-0000-000000000000);
ClearFlag((FLAG)_StatusSetter, _Character); // flagType: Object

IF
FlagSet((FLAG)_StatusClearer, _Character, _) // flagType: Object
AND
DB_DialogStatusSetter((FLAG)_,(FLAG)_StatusClearer,_Status)
THEN
RemoveStatus(_Character,_Status);
ClearFlag((FLAG)_StatusClearer, _Character); // flagType: Object
//END_REGION

//REGION Do N Times
PROC
PROC_QRY_DoNTimesInit()
THEN
DB_QRY_DoNTimesTo100(1);
PROC_QRY_DoNTimesInitNext(1);

PROC
PROC_QRY_DoNTimesInitNext((INTEGER)_Num)
AND
_Num < 100
AND
IntegerSum(_Num,1,_NewNum)
THEN
DB_QRY_DoNTimesTo100(_NewNum);
PROC_QRY_DoNTimesInitNext(_NewNum);

QRY
QRY_DoNTimes((INTEGER)_Integer)
AND
QRY_DoNTimes_Cleanup()
AND
NOT QRY_DoNTimes_IsNegative(_Integer)
THEN
PROC_DoNTimes_SetUp((INTEGER)_Integer);

QRY
QRY_DoNTimes_Cleanup()
AND
DB_QRY_RTN_DoNTimes(_OldValue)
THEN
NOT DB_QRY_RTN_DoNTimes(_OldValue);

QRY
QRY_DoNTimes_Cleanup()
THEN
DB_NOOP(1);

PROC
PROC_DoNTimes_SetUp((INTEGER)_Integer)
AND
_Integer > 0
THEN
PROC_DoNTimes_Batch(0,_Integer);

// Add next 100 entries if more than 100 to go
// (non-recursively)
PROC
PROC_DoNTimes_Batch((INTEGER)_Base,(INTEGER)_Limit)
AND
IntegerSum(_Base,100,_MaxValue)
AND
_MaxValue <= _Limit
AND
DB_QRY_DoNTimesTo100(_Index)
AND
IntegerSum(_Base,_Index,_Value)
THEN
DB_QRY_RTN_DoNTimes(_Value);

// More left -> recurse for the next 100 (or fewer)
PROC
PROC_DoNTimes_Batch((INTEGER)_Base,(INTEGER)_Limit)
AND
IntegerSum(_Base,100,_NewBase)
AND
_Limit > _NewBase
THEN
PROC_DoNTimes_Batch(_NewBase,_Limit);

// Fewer than 100 left -> add recursively (could do this using the
// database as well, but results in a lot of osirislog spam
// because it dumps the entire DB_QRY_DoNTimesTo100 every time,
// so for things like QRY_DoNTimes(1) that's not nice
PROC
PROC_DoNTimes_Batch((INTEGER)_Base,(INTEGER)_Limit)
AND
IntegerSum(_Base,100,_MaxValue)
AND
_MaxValue > _Limit
AND
IntegerSum(_Base,1,_Start)
THEN
PROC_DoNTimes_BatchSmall(_Start,_Limit);

PROC
PROC_DoNTimes_BatchSmall((INTEGER)_Current,(INTEGER)_Limit)
AND
_Current <= _Limit
AND
IntegerSum(_Current,1,_Next)
THEN
DB_QRY_RTN_DoNTimes(_Current);
PROC_DoNTimes_BatchSmall(_Next,_Limit);

QRY
QRY_DoNTimes_IsNegative((INTEGER)_Integer)
AND
_Integer < 0
THEN
DebugBreak("Trying to call Do N Times query with negative number of times. Number needs to be at least 0.");

IF
TextEvent("moveit")
AND
GetHostCharacter(_Player)
THEN
MoveAllItemsTo(_Player,S_DEN_ServantPlight_005_13db744d-8a48-4131-8801-fd5fc289fdf6,0,0,1,0);
//END_REGION

//REGION Loop Counter
QRY
QRY_LoopCounter_Reset((STRING)_Identifier,(INTEGER)_BaseValue)
THEN
DB_Singleton(_Identifier,_BaseValue);

QRY
QRY_LoopCounter_GetCount((STRING)_Identifier)
AND
DB_Singleton(_Identifier,_OldValue)
AND
IntegerSum(_OldValue,1,_NewValue)
THEN
DB_Singleton(_Identifier,_NewValue);
//END_REGION

//REGION Item Thrown Event
IF
OnThrown(_Item,_,_Player,_,_,_,_)
AND
IsItem(_Item,1)
AND
DB_Players((CHARACTER)_Player)
THEN
PROC_ItemThrownByPlayer(_Player,(ITEM)_Item);

PROC
PROC_ItemThrownByPlayer((CHARACTER)_Player,(ITEM)_Item)
THEN
DB_NOOP(1);
//END_REGION

//REGION Compound flag logic
//Keywords: Entail, Dependency

IF
FlagSet((FLAG)_Flag, _, _) // flagType: Global
AND
DB_GLO_CompoundFlag((FLAG)_Flag,(FLAG)_Compound)
THEN
SetFlag((FLAG)_Compound, NULL_00000000-0000-0000-0000-000000000000, 0); // flagType: Global

IF
FlagCleared((FLAG)_Flag, _, _) // flagType: Global
AND
DB_GLO_CompoundFlag((FLAG)_Flag,(FLAG)_Compound)
AND
NOT QRY_GLO_CompoundFlagValid((FLAG)_Compound)
THEN
ClearFlag((FLAG)_Compound, NULL_00000000-0000-0000-0000-000000000000, 0); // flagType: Global

QRY
QRY_GLO_CompoundFlagValid((FLAG)_Compound)
AND
DB_GLO_CompoundFlag((FLAG)_Flag,(FLAG)_Compound)
AND
GetFlag((FLAG)_Flag, NULL_00000000-0000-0000-0000-000000000000, 1) // flagType: Global
THEN
DB_NOOP(1);


//END_REGION

//REGION Exclusive Flag
IF
FlagSet((FLAG)_ExclusiveFlag, _, _)
AND
DB_GLO_ExclusiveFlag((STRING)_ID, (FLAG)_ExclusiveFlag)
THEN
PROC_GLO_ExclusiveFlag_ClearOtherFlags(_ID, _ExclusiveFlag);

PROC
PROC_GLO_ExclusiveFlag_ClearOtherFlags((STRING)_ID, (FLAG)_ExclusiveFlag)
AND
DB_GLO_ExclusiveFlag((STRING)_ID, (FLAG)_OtherFlag)
AND
_OtherFlag != _ExclusiveFlag
AND
DB_GlobalFlag(_OtherFlag)
THEN
PROC_GlobalClearFlagAndCache(_OtherFlag);
//END_REGION Exclusive Flag

//REGION Dialog With Variable Speakers
QRY
QRY_StartDialog_WithVariableSpeakers((DIALOGRESOURCE)_Dialog)
AND
QRY_GetSpeakerForDialogWithVariableSpeakers(_Dialog,1)
AND
DB_QRYRTN_GetSpeakerForDialogWithVariableSpeakers(_Dialog,1,_Speaker1)
AND
QRY_GetSpeakerForDialogWithVariableSpeakers(_Dialog,2)
AND
DB_QRYRTN_GetSpeakerForDialogWithVariableSpeakers(_Dialog,2,_Speaker2)
AND
QRY_GetSpeakerForDialogWithVariableSpeakers(_Dialog,3)
AND
DB_QRYRTN_GetSpeakerForDialogWithVariableSpeakers(_Dialog,3,_Speaker3)
AND
QRY_GetSpeakerForDialogWithVariableSpeakers(_Dialog,4)
AND
DB_QRYRTN_GetSpeakerForDialogWithVariableSpeakers(_Dialog,4,_Speaker4)
AND
QRY_GetSpeakerForDialogWithVariableSpeakers(_Dialog,5)
AND
DB_QRYRTN_GetSpeakerForDialogWithVariableSpeakers(_Dialog,5,_Speaker5)
AND
QRY_GetSpeakerForDialogWithVariableSpeakers(_Dialog,6)
AND
DB_QRYRTN_GetSpeakerForDialogWithVariableSpeakers(_Dialog,6,_Speaker6)
AND
QRY_StartDialog_Fixed(_Dialog,_Speaker1,_Speaker2,_Speaker3,_Speaker4,_Speaker5,_Speaker6)
THEN
DB_NOOP(1);

QRY
QRY_StartDialog_WithVariableSpeakers((DIALOGRESOURCE)_Dialog)
AND
DB_DialogWithVariableSpeakers(_Dialog,_Speaker,_Index)
THEN
NOT DB_DialogWithVariableSpeakers(_Dialog,_Speaker,_Index);

QRY
QRY_StartDialog_WithVariableSpeakers((DIALOGRESOURCE)_Dialog)
AND
DB_QRYRTN_GetSpeakerForDialogWithVariableSpeakers(_Dialog,_Index,_Speaker)
THEN
NOT DB_QRYRTN_GetSpeakerForDialogWithVariableSpeakers(_Dialog,_Index,_Speaker);

QRY
QRY_GetSpeakerForDialogWithVariableSpeakers((DIALOGRESOURCE)_Dialog,(INTEGER)_Index)
AND
DB_DialogWithVariableSpeakers(_Dialog,(GUIDSTRING)_Speaker,_Index)
THEN
DB_QRYRTN_GetSpeakerForDialogWithVariableSpeakers(_Dialog,_Index,_Speaker);

QRY
QRY_GetSpeakerForDialogWithVariableSpeakers((DIALOGRESOURCE)_Dialog,(INTEGER)_Index)
AND
NOT DB_DialogWithVariableSpeakers(_Dialog,_,_Index)
THEN
DB_QRYRTN_GetSpeakerForDialogWithVariableSpeakers(_Dialog,_Index,NULL_00000000-0000-0000-0000-000000000000);
//END_REGION

//REGION Add Nearby Players to Dialog
IF
FlagSet((FLAG)GLO_AddNearbyPlayersToDialog_775fb200-cfe9-0928-e7a2-73b73b2a3ab7,_Anchor,_Instance)
THEN
PROC_Dialog_AddNearbyPlayers(_Instance,_Anchor);
ClearFlag((FLAG)GLO_AddNearbyPlayersToDialog_775fb200-cfe9-0928-e7a2-73b73b2a3ab7,_Anchor,_Instance);

IF
FlagSet((FLAG)GLO_Event_AddNearbyVisiblePlayersToDialog_163ab46a-4625-46fe-8ee6-37fb46d60e52,_Anchor,_Instance)
THEN
PROC_Dialog_AddNearbyVisiblePlayers(_Instance,_Anchor, 0);
ClearFlag((FLAG)GLO_Event_AddNearbyVisiblePlayersToDialog_163ab46a-4625-46fe-8ee6-37fb46d60e52,_Anchor,_Instance);

PROC
PROC_StartDialog_AddNearbySpeakersToDialog((DIALOGRESOURCE)_Dialog,(INTEGER)_ID)
AND
DB_Dialog_AddAllNearbyPlayersAtStart(_Dialog)
AND
DB_DialogRequestCache_SpeakerList_Players(_Dialog,_ID,_Anchor,1)
THEN
PROC_Dialog_AddNearbyPlayers(_ID,_Anchor, 1);

IF
DB_Dialog_AddAllNearbyVisiblePlayersAtStart(_Dialog)
THEN
DB_Dialog_AddAllNearbyVisiblePlayersAtStart((DIALOGRESOURCE)NULL_00000000-0000-0000-0000-000000000000, 0);

PROC
PROC_StartDialog_AddNearbySpeakersToDialog((DIALOGRESOURCE)_Dialog,(INTEGER)_ID)
AND
DB_Dialog_AddAllNearbyVisiblePlayersAtStart(_Dialog, _Speaking)
AND
DB_DialogRequestCache_SpeakerList_Players(_Dialog,_ID,_Anchor,1)
THEN
PROC_Dialog_AddNearbyVisiblePlayers(_ID,_Anchor, _Speaking);

PROC
PROC_Dialog_AddNearbyPlayers((INTEGER)_Instance,(GUIDSTRING)_Anchor)
THEN
PROC_Dialog_AddNearbyPlayers((INTEGER)_Instance,(GUIDSTRING)_Anchor, 0);

PROC
PROC_Dialog_AddNearbyPlayers((INTEGER)_Instance,(GUIDSTRING)_Anchor, 0)
AND
DB_Players(_Player)
AND
NOT DB_InteractiveDialogSpeaker(_Instance,_Player)
AND
QRY_SpeakerIsAvailableAndInDialogRange(_Player,_Anchor)
THEN
PROC_DialogAddListeningActor(_Instance,_Player);
DB_Dialog_IncludedNearbySpeakers(_Instance,_Player);

PROC
PROC_Dialog_AddNearbyPlayers((INTEGER)_Instance,(GUIDSTRING)_Anchor, 1)
AND
DB_Players(_Player)
AND
NOT DB_InteractiveDialogSpeaker(_Instance,_Player)
AND
QRY_SpeakerIsAvailableAndInDialogRange(_Player,_Anchor)
THEN
PROC_DialogAddSpeakingActor(_Instance,_Player);
DB_Dialog_IncludedNearbySpeakers(_Instance,_Player);

PROC
PROC_Dialog_AddNearbyVisiblePlayers((INTEGER)_Instance,(GUIDSTRING)_Anchor, 0)
AND
DB_Players(_Player)
AND
NOT DB_InteractiveDialogSpeaker(_Instance,_Player)
AND
NOT QRY_CharacterIsHidden(_Player)
AND
QRY_SpeakerIsAvailableAndInDialogRange(_Player,_Anchor)
THEN
PROC_DialogAddListeningActor(_Instance,_Player);
DB_Dialog_IncludedNearbySpeakers(_Instance,_Player);

PROC
PROC_Dialog_AddNearbyVisiblePlayers((INTEGER)_Instance,(GUIDSTRING)_Anchor, 1)
AND
DB_Players(_Player)
AND
NOT DB_InteractiveDialogSpeaker(_Instance,_Player)
AND
NOT QRY_CharacterIsHidden(_Player)
AND
QRY_SpeakerIsAvailableAndInDialogRange(_Player,_Anchor)
THEN
PROC_DialogAddSpeakingActor(_Instance,_Player);
DB_Dialog_IncludedNearbySpeakers(_Instance,_Player);

//END_REGION

//REGION Create database with N entries of which the first ones are filled with the players and the rest with null
QRY
QRY_CreateIndexedPlayerDB((INTEGER)_MaxIndex)
THEN
SysClear("DB_QRYRTN_CreateIndexedPlayerDB", 2);
PROC_DeclareCounter("QRY_CreateIndexedPlayerDB_Counter");
PROC_IncreaseCounter("QRY_CreateIndexedPlayerDB_Counter");

QRY
QRY_CreateIndexedPlayerDB((INTEGER)_MaxIndex)
AND
QRY_DoNTimes(_MaxIndex)
AND
DB_QRY_RTN_DoNTimes(_Index)
THEN
DB_QRYRTN_CreateIndexedPlayerDB(_Index, (CHARACTER)NULL_00000000-0000-0000-0000-000000000000);

QRY
QRY_CreateIndexedPlayerDB((INTEGER)_MaxIndex)
AND
DB_Players(_Player)
AND
DB_GlobalCounter("QRY_CreateIndexedPlayerDB_Counter", _Index)
THEN
NOT DB_QRYRTN_CreateIndexedPlayerDB(_Index, NULL_00000000-0000-0000-0000-000000000000);
DB_QRYRTN_CreateIndexedPlayerDB(_Index, _Player);
PROC_IncreaseCounter("QRY_CreateIndexedPlayerDB_Counter");
//END_REGION

//REGION Global Flag Inverter
IF
DB_GlobalFlagInverter((FLAG)_FlagA,(FLAG)_FlagNotA)
AND
DB_GlobalFlag(_FlagA)
AND
DB_GlobalFlag(_FlagNotA)
THEN
ClearFlag(_FlagNotA,NULL_00000000-0000-0000-0000-000000000000,0);

IF
DB_GlobalFlagInverter((FLAG)_FlagA,(FLAG)_FlagNotA)
AND
NOT DB_GlobalFlag(_FlagNotA)
AND
NOT DB_GlobalFlag(_FlagA)
THEN
SetFlag(_FlagNotA,NULL_00000000-0000-0000-0000-000000000000,0);
//END_REGION

//REGION Filter out certain speakers
QRY
QRY_ObjectFilterOut((GUIDSTRING)_Object,(GUIDSTRING)_Filter)
AND
DB_QRYRTN_ObjectFilterOut(_OldData)
THEN
NOT DB_QRYRTN_ObjectFilterOut(_OldData);

QRY
QRY_ObjectFilterOut((GUIDSTRING)_Object,(GUIDSTRING)_Filter)
AND
_Object == _Filter
THEN
DB_QRYRTN_ObjectFilterOut(NULL_00000000-0000-0000-0000-000000000000);

QRY
QRY_ObjectFilterOut((GUIDSTRING)_Object,(GUIDSTRING)_Filter)
AND
_Object != _Filter
THEN
DB_QRYRTN_ObjectFilterOut(_Object);
//END_REGION

//REGION Inspiration
IF
FlagSet(GLO_Inspiration_Event_Add1_9f7abafd-ef49-47c7-a7e8-a2fb068dedf2,_Char,_)
THEN
GiveInspirationPoints((CHARACTER)_Char, 1.0, "", "");
ClearFlag(GLO_Inspiration_Event_Add1_9f7abafd-ef49-47c7-a7e8-a2fb068dedf2,_Char);
//END_REGION

//REGION Surprised status handling
PROC
PROC_MakeSurprised((GUIDSTRING)_Object)
THEN
PROC_MakeSurprised((GUIDSTRING)_Object, 1, 0);

PROC
PROC_MakeSurprised((GUIDSTRING)_Object, (INTEGER)_Turns, (INTEGER) _Forced)
AND
_Turns != -1
AND
NOT QRY_HasLongerSurpriseThan(_Object, _Turns)
AND
IntegerProduct(_Turns,6,_Time)
AND
IntegerToReal(_Time,_Duration)
THEN
ApplyStatus(_Object, "SURPRISED", _Duration, _Forced);

QRY
QRY_HasLongerSurpriseThan((GUIDSTRING)_Object, (INTEGER)_NewDuration)
AND
GetStatusTurns(_Object, "SURPRISED", _Duration)
AND
_Duration > _NewDuration
THEN
DB_NOOP(1);

QRY
QRY_HasLongerSurpriseThan((GUIDSTRING)_Object, (INTEGER)_NewDuration)
AND
GetStatusTurns(_Object, "SURPRISED", _Duration)
AND
_Duration == -1
THEN
DB_NOOP(1);

PROC
PROC_MakeSurprised((GUIDSTRING)_Object, -1, (INTEGER) _Forced)
THEN
ApplyStatus(_Object, "SURPRISED", -1.0, _Forced);
//END_REGION

//REGION Prevent Fast Travel
//via Waypoints; (QRY_GLO_BlockTeleportToWaypoint)
//via Long Rest button; (QRY_Camp_CheckPlayersReadyForNightModeStoryReasons)
//via Fast Travel to Camp; (QRY_Camp_IsPlayerBlockedFromTeleportToCamp)
QRY
QRY_Camp_CheckPlayersReadyForNightModeStoryReasons()
AND
QRY_REALLY_BlockFastTravel(NULL_00000000-0000-0000-0000-000000000000)
THEN
DB_Camp_PlayerNotReadyForNightMode_CustomStoryReason("REALLY_BlockFastTravel");

// Char, Teleporting
QRY
QRY_Camp_IsPlayerBlockedFromTeleportToCamp((CHARACTER)_Char)
AND
QRY_Camp_IsPlayerBlockedFromTeleportToCamp((CHARACTER)_Char, 1)
THEN
DB_NOOP(1);

QRY
QRY_Camp_IsPlayerBlockedFromTeleportToCamp((CHARACTER)_Char, 1)
AND
QRY_REALLY_BlockFastTravel(_Char)
THEN
DB_NOOP(1);

QRY
QRY_GLO_BlockTeleportToWaypoint(_Char,_)
AND
QRY_REALLY_BlockFastTravel(_Char)
THEN
DB_NOOP(1);

QRY
QRY_REALLY_BlockFastTravel((CHARACTER)_Char)
AND
1 == 0
THEN
DB_NOOP(1);
//END_REGION

//REGION InRegion Character Flags
IF
EnteredTrigger(_Character,_Trigger)
AND
DB_InRegionFlag(_Trigger,_Flag)
THEN
SetFlag(_Flag,_Character,0);

IF
LeftTrigger(_Character,_Trigger)
AND
DB_InRegionFlag(_Trigger,_Flag)
THEN
ClearFlag(_Flag,_Character,0);

IF
DB_CharacterInRegionFlag(_Character,_Trigger,_Flag)
AND
NOT DB_CharacterInRegionFlag_Set(_Character,_Trigger,_Flag)
THEN
DB_CharacterInRegionFlag_Set(_Character,_Trigger,_Flag);
TriggerRegisterForCharacter(_Trigger,_Character);

IF
DB_CharacterInRegionFlag_Set(_Character,_Trigger,_Flag)
AND
NOT DB_CharacterInRegionFlag(_Character,_Trigger,_Flag)
THEN
NOT DB_CharacterInRegionFlag_Set(_Character,_Trigger,_Flag);
TriggerUnregisterForCharacter(_Trigger,_Character);
ClearFlag(_Flag,_Character,0);

IF
EnteredTrigger(_Character,_Trigger)
AND
DB_CharacterInRegionFlag(_Character,_Trigger,_Flag)
THEN
SetFlag(_Flag,_Character,0);

IF
LeftTrigger(_Character,_Trigger)
AND
DB_CharacterInRegionFlag(_Character,_Trigger,_Flag)
THEN
ClearFlag(_Flag,_Character,0);
//END_REGION

//REGION InRegion Item Flags
IF
DB_ItemInRegionFlag(_Item,_Trigger,_Flag)
AND
NOT DB_ItemInRegionFlag_Set(_Item,_Trigger,_Flag)
THEN
PROC_ItemInRegionFlag_Register(_Item,_Trigger,_Flag);
DB_ItemInRegionFlag_Set(_Item,_Trigger,_Flag);

PROC
PROC_ItemInRegionFlag_Register((ITEM)_Item,(TRIGGER)_Trigger,(FLAG)_Flag)
AND
NOT DB_ItemInRegionFlag_Set(_,_Trigger,_)
THEN
TriggerRegisterForItems(_Trigger);

IF
DB_ItemInRegionFlag_Set(_Item,_Trigger,_Flag)
AND
NOT DB_ItemInRegionFlag(_Item,_Trigger,_Flag)
THEN
NOT DB_ItemInRegionFlag_Set(_Item,_Trigger,_Flag);
PROC_GlobalClearFlagAndCache(_Flag);
PROC_ItemInRegionFlag_Unregister(_Item,_Trigger,_Flag);

PROC
PROC_ItemInRegionFlag_Unregister((ITEM)_Item,(TRIGGER)_Trigger,(FLAG)_Flag)
AND
NOT DB_ItemInRegionFlag_Set(_,_Trigger,_)
THEN
TriggerUnregisterForItems(_Trigger);

IF
DB_ItemInRegionFlag_Set(_Item,_Trigger,_Flag)
AND
NOT DB_GlobalFlag(_Flag)
AND
IsInTrigger(_Item,_Trigger,1)
THEN
PROC_GlobalSetFlagAndCache(_Flag);

IF
ItemEnteredTrigger(_Item,_Trigger,_)
AND
DB_ItemInRegionFlag(_Item,_Trigger,_Flag)
THEN
PROC_GlobalSetFlagAndCache(_Flag);

IF
ItemLeftTrigger(_Item,_Trigger,_)
AND
DB_ItemInRegionFlag(_Item,_Trigger,_Flag)
THEN
PROC_GlobalClearFlagAndCache(_Flag);
//END_REGION

//REGION Data Validation
QRY
QRY_CheckInputInteger((INTEGER)_Min,(INTEGER)_Value,(INTEGER)_Max,(STRING)_Identifier)
AND
_Value >= _Min
AND
_Value <= _Max
THEN
DB_NOOP(1);

QRY
QRY_CheckInputInteger((INTEGER)_Min,(INTEGER)_Value,(INTEGER)_Max,(STRING)_Identifier)
AND
_Value < _Min
AND
ConcatenateInteger("QRY_CheckInputInteger: Value (",_Value,_Substring1)
AND
Concatenate(_Substring1,") does not fall in range [",_Substring2)
AND
ConcatenateInteger(_Substring2,_Min,_Substring3)
AND
Concatenate(_Substring3,",",_Substring4)
AND
ConcatenateInteger(_Substring4,_Max,_Substring5)
AND
Concatenate(_Substring5,"] for check: ",_Substring6)
AND
Concatenate(_Substring6,_Identifier,_FinalString)
AND
QRY_ShowError(_FinalString)
AND
0 == 1
THEN
DB_NOOP(1);

QRY
QRY_CheckInputInteger((INTEGER)_Min,(INTEGER)_Value,(INTEGER)_Max,(STRING)_Identifier)
AND
_Value > _Max
AND
ConcatenateInteger("QRY_CheckInputInteger: Value (",_Value,_Substring1)
AND
Concatenate(_Substring1,") does not fall in range [",_Substring2)
AND
ConcatenateInteger(_Substring2,_Min,_Substring3)
AND
Concatenate(_Substring3,",",_Substring4)
AND
ConcatenateInteger(_Substring4,_Max,_Substring5)
AND
Concatenate(_Substring5,"] for check: ",_Substring6)
AND
Concatenate(_Substring6,_Identifier,_FinalString)
AND
QRY_ShowError(_FinalString)
AND
0 == 1
THEN
DB_NOOP(1);

QRY
QRY_ShowError((STRING)_ErrorMessage)
THEN
DebugBreak(_ErrorMessage);
//END_REGION

//REGION Boolean to integer
QRY
QRY_GetGuidsEqual((GUIDSTRING)_Guid, (GUIDSTRING)_Guid)
THEN
NOT DB_QRYRTN_GetGuidsEqual(0);
DB_QRYRTN_GetGuidsEqual(1);

QRY
QRY_GetGuidsEqual((GUIDSTRING)_Guid1, (GUIDSTRING)_Guid2)
AND
_Guid1 != _Guid2
THEN
NOT DB_QRYRTN_GetGuidsEqual(0);
DB_QRYRTN_GetGuidsEqual(1);
//END_REGION

//REGION Notify when ready to move on: not in or entering any state that requires the NPC to stay where they are right now
// Notifies when none of the following hold anymore:
//   - entering combat
//   - in combat
//   - can't move (includes being in an interactive dialog)
//   - reacting to a non-background disturbance
//   - polymorphed by a player (as opposed to e.g. wildshaped or disguised)
PROC
PROC_NotifyWhenReadyToMoveOn((CHARACTER)_NPC,(STRING)_Identifier)
THEN
DB_NotifyWhenReadyToMoveOn(_NPC,_Identifier);

IF
DB_NotifyWhenReadyToMoveOn(_NPC,_Identifier)
AND
NOT DB_Is_HandlingDisturbance(_NPC,0)
AND
NOT DB_CantMove(_NPC)
AND
NOT DB_Is_InCombat(_NPC,_)
AND
NOT DB_EnterCombatRequested(_NPC)
AND
NOT DB_Is_PolymorphedByPlayer(_NPC)
AND
NOT DB_Defeated(_NPC)
AND
NOT DB_Offstage(_NPC)
AND
IsInCombat(_NPC, 0) //To address SwitchedCombat causing the execution to fire because DB_Is_InCombat is cleared before being set to the new combat guid.
THEN
NOT DB_NotifyWhenReadyToMoveOn(_NPC,_Identifier);
PROC_ReadyToMoveOn(_NPC,_Identifier);

IF
DB_NotifyWhenReadyToMoveOn(_NPC,_Identifier)
AND
DB_Defeated(_NPC)
THEN
NOT DB_NotifyWhenReadyToMoveOn(_NPC,_Identifier);
PROC_ReadyToMoveOn_Failed(_NPC,_Identifier);

IF
DB_NotifyWhenReadyToMoveOn(_NPC,_Identifier)
AND
DB_Offstage(_NPC)
THEN
NOT DB_NotifyWhenReadyToMoveOn(_NPC,_Identifier);
PROC_ReadyToMoveOn_Failed(_NPC,_Identifier);


PROC
PROC_ReadyToMoveOn((CHARACTER)_NPC,(STRING)_Identifier)
THEN
DB_NOOP(1);

PROC
PROC_ReadyToMoveOn_Failed((CHARACTER)_NPC,(STRING)_Identifier)
THEN
DB_NOOP(1);
//END_REGION

//REGION Notify when a character can talk

// Notifies when a character becomes available to talk:
//   - set _IgnoreCombat to 1, if you don't care if that character is in the combat

PROC
PROC_NotifyWhenReadyToTalk((CHARACTER)_Character,(STRING)_Identifier)
THEN
PROC_NotifyWhenReadyToTalk((CHARACTER)_Character,(STRING)_Identifier,0);

PROC
PROC_NotifyWhenReadyToTalk((CHARACTER)_Character,(STRING)_Identifier,(INTEGER)_IgnoreCombat)
THEN
DB_NotifyWhenReadyToTalk(_Character,_Identifier,_IgnoreCombat);

PROC
PROC_NotifyWhenReadyToTalk_Cancel((CHARACTER)_Character,(STRING)_Identifier)
AND
DB_NotifyWhenReadyToTalk(_Character,_Identifier,_IgnoreCombat)
THEN
NOT DB_NotifyWhenReadyToTalk(_Character,_Identifier,_IgnoreCombat);

IF
DB_NotifyWhenReadyToTalk(_Character,_Identifier,0)
AND
NOT DB_CantTalk(_Character)
THEN
NOT DB_NotifyWhenReadyToTalk(_Character,_Identifier,0);
PROC_ReadyToTalk(_Character,_Identifier);

IF
DB_NotifyWhenReadyToTalk(_Character,_Identifier,1)
AND
NOT DB_CantTalk_IgnoreCombat(_Character)
THEN
NOT DB_NotifyWhenReadyToTalk(_Character,_Identifier,1);
PROC_ReadyToTalk(_Character,_Identifier);

IF
DB_NotifyWhenReadyToTalk(_Character,_Identifier,_IgnoreCombat)
AND
DB_Defeated(_Character)
THEN
NOT DB_NotifyWhenReadyToTalk(_Character,_Identifier,_IgnoreCombat);
PROC_ReadyToTalk_Failed(_Character,_Identifier);

IF
DB_NotifyWhenReadyToTalk(_Character,_Identifier,_IgnoreCombat)
AND
DB_Offstage(_Character)
THEN
NOT DB_NotifyWhenReadyToTalk(_Character,_Identifier,_IgnoreCombat);
PROC_ReadyToTalk_Failed(_Character,_Identifier);

PROC
PROC_ReadyToTalk((CHARACTER)_Character,(STRING)_Identifier)
THEN
DB_NOOP(1);

PROC
PROC_ReadyToTalk_Failed((CHARACTER)_Character,(STRING)_Identifier)
THEN
DB_NOOP(1);

//END_REGION

//REGION Apply damage that will never kill the character
PROC
PROC_ApplyLimitedDamagePercent((CHARACTER)_Character, (REAL)_DamagePercent, (STRING)_DamageType, (CHARACTER)_Source)
AND
GetHitpoints(_Character, _CurrentHP)
AND
_CurrentHP > 1
AND
IntegerSubtract(_CurrentHP, 1, _MaxDmgToApply)
AND
GetMaxHitpoints(_Character, _MaxHP)
AND
IntegerToReal(_MaxHP, _MaxHPReal)
AND
RealProduct(_MaxHPReal, _DamagePercent, _HPDmg100)
AND
RealDivide(_HPDmg100, 100.0, _HPDmgReal)
AND
RealToInteger(_HPDmgReal, _HPDmg)
AND
IntegerMax(_HPDmg, 1, _HPDmgAtLeastOne)
AND
IntegerMin(_MaxDmgToApply, _HPDmgAtLeastOne, _DmgToApply)
AND
_DmgToApply > 0
THEN
ApplyDamage(_Character, _DmgToApply, _DamageType, _Source);
//END_REGION

//REGION Reading book flags

//Sets global flag after reading a book
//DB_BookFlags((ITEM)_Book,(FLAG)_Flag);
IF
GameBookInterfaceClosed(_Book,_Character)
AND
DB_BookFlags((ITEM)_Book,(FLAG)_Flag)
AND
DB_PartyMembers(_Character)
AND
NOT DB_GlobalFlag(_Flag)
THEN
PROC_GlobalSetFlagAndCache((FLAG)_Flag);
PROC_BookFlags_FlagSet(_Book,_Flag,_Character);

IF
GameBookInterfaceClosed(_Book, _Character)
AND
DB_BookTemplateFlags((ITEMROOT)_BookTemplate, (FLAG)_Flag)
AND
GetTemplate(_Book, _BookTemplate)
AND
DB_PartyMembers(_Character)
AND
NOT DB_GlobalFlag(_Flag)
THEN
PROC_GlobalSetFlagAndCache((FLAG)_Flag);
PROC_BookFlags_FlagSet(_Book,_Flag,_Character);

PROC
PROC_BookFlags_FlagSet((ITEM)_Book,(FLAG)_Flag,(CHARACTER)_Reader)
THEN
DB_NOOP(1);

//END_REGION

//REGION Entities fading in and out

IF
TextEvent("fa_fadeout")
AND
GetDebugCharacter(_Character)
THEN
PROC_FadeOutEntity(_Character);

IF
TextEvent("fa_fadein")
AND
GetDebugCharacter(_Character)
THEN
PROC_FadeInEntity(_Character);

PROC
PROC_FadeOutEntity((GUIDSTRING)_Entity)
THEN
PROC_FadeOutEntity(_Entity,"");

PROC
PROC_FadeInEntity((GUIDSTRING)_Entity)
THEN
PROC_FadeInEntity(_Entity,"");

QRY
QRY_FadeAppear_TrySetOnStage((GUIDSTRING)_Entity,(INTEGER)_OnStage)
AND
NOT IsOnStage(_Entity,_OnStage)
THEN
SetOnStage(_Entity,_OnStage);

//Cancel fade in
PROC
PROC_FadeOutEntity((GUIDSTRING)_Entity,(STRING)_FadeEndEvent)
AND
DB_FadeAppear(_Entity,1,_Event) //fading in
THEN
ObjectTimerCancel(_Entity,"FadeAppear_FadeIn_Delay");
ObjectTimerCancel(_Entity,"FadeAppear_FadeIn_Anim");
RemoveStatus(_Entity,"FADE_APPEAR",NULL_00000000-0000-0000-0000-000000000000);
PROC_FadeAppear_FadeOver(_Entity);

//Cancel fade out
PROC
PROC_FadeInEntity((GUIDSTRING)_Entity,(STRING)_FadeEndEvent)
AND
DB_FadeAppear(_Entity,0,_Event) //fading out
THEN
ObjectTimerCancel(_Entity,"FadeAppear_FadeIn_Delay");
ObjectTimerCancel(_Entity,"FadeAppear_FadeIn_FadeOut_Anim");
RemoveStatus(_Entity,"FADE_APPEAR",NULL_00000000-0000-0000-0000-000000000000);
PROC_FadeAppear_FadeOver(_Entity);

//Fade out
PROC
PROC_FadeOutEntity((GUIDSTRING)_Entity,(STRING)_FadeEndEvent)
AND
NOT DB_FadeAppear(_Entity,_,_)
THEN
DB_FadeAppear(_Entity,0,_FadeEndEvent);
ApplyStatus(_Entity,"FADE_APPEAR",-1.0,1,NULL_00000000-0000-0000-0000-000000000000); //purely visual status that provides the fading visual

IF
StatusAttempt(_Entity,"FADE_APPEAR",_,_)
AND
DB_FadeAppear(_Entity,0,_FadeEndEvent)
THEN
RealtimeObjectTimerLaunch(_Entity,"FadeAppear_FadeOut_Anim",1000);

IF
ObjectTimerFinished(_Entity,"FadeAppear_FadeOut_Anim") //Ensures the status fading out animation is done
AND
DB_FadeAppear(_Entity,0,_FadeEndEvent)
AND
NOT QRY_FadeAppear_TrySetOnStage(_Entity,0)
THEN
PROC_FadeAppear_FadeOver(_Entity);

IF
WentOnStage(_Entity,0)
AND
DB_FadeAppear(_Entity,0,_FadeEndEvent)
THEN
PROC_FadeAppear_FadeOver(_Entity);

//Fade in
PROC
PROC_FadeInEntity((GUIDSTRING)_Entity,(STRING)_FadeEndEvent)
AND
NOT DB_FadeAppear(_Entity,_,_)
THEN
DB_FadeAppear(_Entity,1,_FadeEndEvent);
ApplyStatus(_Entity,"FADE_APPEAR",-1.0,1,NULL_00000000-0000-0000-0000-000000000000); //purely visual status that provides the fading visual
RealtimeObjectTimerLaunch(_Entity,"FadeAppear_FadeIn_FadeOut_Anim",1000);

IF
ObjectTimerFinished(_Entity,"FadeAppear_FadeIn_FadeOut_Anim") //Ensures the status fading in animation is done
AND
DB_FadeAppear(_Entity,1,_)
AND
NOT QRY_FadeAppear_TrySetOnStage(_Entity,1)
THEN
RealtimeObjectTimerLaunch(_Entity,"FadeAppear_FadeIn_Delay",500);

IF
WentOnStage(_Entity,1)
AND
DB_FadeAppear(_Entity,1,_)
THEN
RealtimeObjectTimerLaunch(_Entity,"FadeAppear_FadeIn_Delay",500);

IF
ObjectTimerFinished(_Entity,"FadeAppear_FadeIn_Delay")
THEN
RemoveStatus(_Entity,"FADE_APPEAR",_Entity);

IF
StatusRemoved(_Entity,"FADE_APPEAR",_,_)
AND
DB_FadeAppear(_Entity,1,_FadeEndEvent)
THEN
RealtimeObjectTimerLaunch(_Entity,"FadeAppear_FadeIn_Anim",1000);

IF
ObjectTimerFinished(_Entity,"FadeAppear_FadeIn_Anim") //Ensures the status animation is done
AND
DB_FadeAppear(_Entity,1,_FadeEndEvent)
THEN
PROC_FadeAppear_FadeOver(_Entity);

//Fade in/out is complete - clean up and send event
PROC
PROC_FadeAppear_FadeOver((GUIDSTRING)_Entity)
AND
DB_FadeAppear(_Entity,_FadeIn,_FadeEndEvent)
AND
_FadeEndEvent != ""
THEN
SetEntityEvent(_Entity,_FadeEndEvent);

PROC
PROC_FadeAppear_FadeOver((GUIDSTRING)_Entity)
AND
DB_FadeAppear(_Entity,_FadeIn,_FadeEndEvent)
THEN
NOT DB_FadeAppear(_Entity,_FadeIn,_FadeEndEvent);

//END_REGION

//REGION Corpse Cleanup (Remove corpse & blood and leave loot bag)
//We only track Death instead of permadefeated. The other forms have their own handling (knockout etc.)
IF
Died(_Corpse)
AND
NOT DB_CorpseCleanup_Ignore(_Corpse)
AND
NOT DB_CanBeResurrected(_Corpse)
AND
NOT DB_GLO_CharacterCorpseDialog(_Corpse,_)
AND
GetDefaultState(_Corpse, "")
THEN
DB_CorpseCleanup_ReadyToBeRemoved(_Corpse);

PROC
PROC_LongRest()
AND
DB_CorpseCleanup_ReadyToBeRemoved(_Corpse)
AND
DB_Dead(_Corpse) //Double check it's still dead
AND
NOT DB_CanBeResurrected(_Corpse) //Double check it's still not resurrectable.
AND
IsInInventory(_Corpse, 0)
AND
GetRegion(_Corpse,_Region)
AND
DB_CurrentLevel(_Region) //Double check the corpse is still in the active region
AND
DB_CorpseCleanup_Area(_CorpseCleanup_Area) //Loop over all corpse cleanup triggers
AND
NOT DB_OffStage(_Corpse) //Loop Breaker
AND
GetRegion(_CorpseCleanup_Area,_Region) //Make sure the trigger is in this level
AND
IsInTrigger(_Corpse,_CorpseCleanup_Area,1) //Make sure the corpse is in a trigger
THEN
PROC_CorpseCleanup_RemoveCorpse((CHARACTER)_Corpse);

PROC
PROC_CorpseCleanup_RemoveCorpse((CHARACTER)_Corpse)
THEN
CreateSurface(_Corpse, "SurfaceNone", 2.0, -1.0, NULL_00000000-0000-0000-0000-000000000000); //Remove blood
PROC_CorpseCleanup_CreateLootbag(_Corpse);
PROC_SetOnStage(_Corpse,0);

PROC
PROC_CorpseCleanup_CreateLootbag((CHARACTER)_Corpse)
AND
DB_ActiveLevel(_)
AND
NOT DB_Origins(_Corpse)
AND
IsInventoryEmpty(_Corpse,0) 
AND
GetPosition(_Corpse,_X,_Y,_Z)
AND
CreateAt((ITEMROOT)CONT_GEN_Pouch_Leather_A_2e40240b-77d3-400b-bd6a-caff66a85833,_X,_Y,_Z,0,0,"CorpseCleanup_LootbagReady",_BackPack) //non-origin - pouch
THEN
DB_CorpseCleanup_DeferredWait(_Corpse,_BackPack);
DB_CorpseCleanup_Lootbag(_BackPack);

PROC
PROC_CorpseCleanup_CreateLootbag((CHARACTER)_Corpse)
AND
DB_ActiveLevel(_)
AND
DB_Origins(_Corpse)
AND
IsInventoryEmpty(_Corpse,0) 
AND
GetPosition(_Corpse,_X,_Y,_Z)
AND
CreateAt((ITEMROOT)LOOT_GEN_Backpack_D_Posed_A_Colorvar_B_f697d433-7b8f-4fe1-8fe3-990bdfeedeee,_X,_Y,_Z,0,0,"CorpseCleanup_LootbagReady",_BackPack) //origin - backpack
THEN
DB_CorpseCleanup_DeferredWait(_Corpse,_BackPack);
DB_CorpseCleanup_Lootbag(_BackPack);

PROC
PROC_CorpseCleanup_CreateLootbag((CHARACTER)_Corpse)
AND
NOT DB_ActiveLevel(_)
THEN
DB_CorpseCleanup_WaitForCorpse(_Corpse);

IF
DB_ActiveLevel(_Level)
AND
DB_CorpseCleanup_WaitForCorpse(_Corpse)
AND
Exists(_Corpse, 1)
AND
GetRegion(_Corpse, _Level)
THEN
PROC_CorpseCleanup_CreateLootbag((CHARACTER)_Corpse);

IF
EntityEvent((ITEM)_BackPack,"CorpseCleanup_LootbagReady")
AND
DB_CorpseCleanup_DeferredWait(_Corpse,_BackPack)
THEN
PROC_CorpseCleanup_SetupBackpack(_Corpse, _Backpack);

PROC
PROC_CorpseCleanup_SetupBackpack((CHARACTER)_Corpse, (ITEM)_Backpack)
THEN
SetOwner(_BackPack,_Corpse);
MoveAllLootableItemsTo(_Corpse,_BackPack,1,1,1,0);
NOT DB_CorpseCleanup_DeferredWait(_Corpse,_BackPack);
NOT DB_CorpseCleanup_WaitForCorpse(_Corpse);

PROC
PROC_CorpseCleanup_SetupBackpack((CHARACTER)_Corpse, (ITEM)_)
AND
DB_CorpseCleanup_DeferredWait_ForLevel(_Corpse,_BackPack)
THEN
NOT DB_CorpseCleanup_DeferredWait_ForLevel(_Corpse,_BackPack);

IF
DB_CorpseCleanup_DeferredWait(_Corpse,_BackPack)
AND
NOT DB_ActiveLevel(_)
THEN
DB_CorpseCleanup_DeferredWait_ForLevel(_Corpse,_BackPack);
NOT DB_CorpseCleanup_DeferredWait(_Corpse,_BackPack);

IF
DB_ActiveLevel(_Level)
AND
DB_CorpseCleanup_DeferredWait_ForLevel(_Corpse,_BackPack)
AND
Exists(_Corpse, 1)
AND
GetRegion(_Corpse, _Level)
AND
Exists(_Backpack, 1)
AND
GetRegion(_Backpack, _Level)
THEN
NOT DB_CorpseCleanup_DeferredWait_ForLevel(_Corpse,_BackPack);
PROC_CorpseCleanup_SetupBackpack((CHARACTER)_Corpse, (ITEM)_Backpack);

//Finally remove all entries from the database, whether they were converted to a lootbag or not. Checking once is enough.
PROC
PROC_LongRest()
AND
DB_CorpseCleanup_ReadyToBeRemoved(_Corpse)
THEN
NOT DB_CorpseCleanup_ReadyToBeRemoved(_Corpse);

//If players pick up a loot backpack, it should no longer be deleted when empty
IF
AddedTo(_Lootbackpack,_,_)
AND
DB_CorpseCleanup_Lootbag(_Lootbackpack)
THEN
NOT DB_CorpseCleanup_Lootbag(_Lootbackpack);

IF
RemovedFrom(_Any,_Lootbackpack)
AND
DB_CorpseCleanup_Lootbag(_Lootbackpack)
AND
IsInventoryEmpty(_Lootbackpack,1)
THEN
Die((ITEM)_Lootbackpack);
NOT DB_CorpseCleanup_Lootbag(_Lootbackpack);

//END_REGION

//REGION In combat together

QRY
QRY_IsInCombatWith((GUIDSTRING)_A,(GUIDSTRING)_B)
AND
DB_Is_InCombat(_A,_CombatId)
AND
DB_Is_InCombat(_B,_CombatId)
THEN
DB_NOOP(1);

//END_REGION

//REGION Party composition helpers
QRY
QRY_IsNotAloneInPartyGroup((CHARACTER)_Char)
AND
DB_Players(_Other)
AND
_Char != _Other
AND
InSamePartyGroup(_Char,_Other,1)
THEN
DB_NOOP(1);

//END_REGION

//REGION Debug Database Printing from Recon
IF
TextEvent("dbcount")
AND
GetTextEventParamString(1,_DBName)
AND
GetTextEventParamInteger(2,_DBArity)
AND
GetHostCharacter(_Player)
THEN
PROC_DBDEBUG_PrintCount(_Player,_DBName,_DBArity);

IF
TextEvent("dbcount")
AND
GetTextEventParamString(1,_DBName)
AND
NOT GetTextEventParamInteger(2,_)
AND
GetHostCharacter(_Player)
THEN
PROC_DBDEBUG_PrintCount(_Player,_DBName,1);
PROC_DBDEBUG_PrintCount(_Player,_DBName,2);
PROC_DBDEBUG_PrintCount(_Player,_DBName,3);
PROC_DBDEBUG_PrintCount(_Player,_DBName,4);
PROC_DBDEBUG_PrintCount(_Player,_DBName,5);

PROC
PROC_DBDEBUG_PrintCount((CHARACTER)_Player,(STRING)_DBName,(INTEGER)_DBArity)
AND
SysCount(_DBName,_DBArity,_Count)
AND
_Count > 0
AND
Concatenate("#",_DBName,_Substr1)
AND
Concatenate(_Substr1,"(",_Substr2)
AND
ConcatenateInteger(_Substr2,_DBArity,_Substr3)
AND
Concatenate(_Substr3,") = ",_Substr4)
AND
ConcatenateInteger(_Substr4,_Count,_Endstring)
THEN
DebugText(_Player,_Endstring);

IF
TextEvent("dblist")
AND
GetTextEventParamString(1,_DBName)
AND
GetHostCharacter(_Player)
THEN
NOT DB_DBDebug_FoundReturnDB(1);
NOT DB_DBDebug_DBFound(1);
PROC_DBDebug_DBList(_Player,_DBName);
PROC_DBDebug_CheckSuccess(_Player,_DBName);

PROC
PROC_DBDebug_DBList((CHARACTER)_Player,(STRING)_DBName)
AND
DB_DBDebug_ReturnDBs(_DBArity,_ReturnDB)
THEN
PROC_DBDebug_DBList_Loop(_Player,_ReturnDB,_DBName,_DBArity,1);

PROC
PROC_DBDebug_CheckSuccess((CHARACTER)_Player,(STRING)_DBName)
THEN
PROC_DBDebug_TryCount(_DBName,1);
PROC_DBDebug_TryCount(_DBName,2);
PROC_DBDebug_TryCount(_DBName,3);
PROC_DBDebug_TryCount(_DBName,4);
PROC_DBDebug_TryCount(_DBName,5);
PROC_DBDebug_TryCount(_DBName,6);
PROC_DBDebug_TryCount(_DBName,7);
PROC_DBDebug_TryCount(_DBName,8);
PROC_DBDebug_TryCount(_DBName,9);
PROC_DBDebug_TryCount(_DBName,10);

PROC
PROC_DBDebug_TryCount((STRING)_DBName,(INTEGER)_Arity)
AND
SysCount(_DBName,_Arity,_Count)
AND
_Count > 0
THEN
DB_DBDebug_DBFound(1);	

PROC
PROC_DBDebug_CheckSuccess((CHARACTER)_Player,(STRING)_DBName)
AND
NOT DB_DBDebug_DBFound(1)
AND
Concatenate("No entries found for ",_DBName,_Outstring)
THEN
DebugText(_Player,_Outstring);

PROC
PROC_DBDebug_CheckSuccess((CHARACTER)_Player,(STRING)_DBName)
AND
DB_DBDebug_DBFound(1)
AND
NOT DB_DBDebug_FoundReturnDB(1) 
AND
Concatenate("No usable return DB found for ",_DBName,_Outstring)
THEN
DebugText(_Player,_Outstring);
DebugText(_Player,"Add a definition to DB_DBDebug_ReturnDBs");

PROC
PROC_DBDebug_DBList_Loop((CHARACTER)_Player,(STRING)_ReturnDB,(STRING)_DBName,(INTEGER)_DBArity,(INTEGER)_Index)
AND
IntegerSum(_Index,1,_NewIndex)
AND
SysFactAtIndex(_DBName,_DBArity,_Index,_ReturnDB)
AND
QRY_DBDebug_FactToString(_ReturnDB)
AND
DB_QRYRTN_DBDebug_FactToString(_EntryString)
AND
Concatenate(_DBName,"(",_Substr1)
AND
Concatenate(_Substr1,_EntryString,_Substr2)
AND
Concatenate(_Substr2,");",_Endstring)
THEN
SysClear(_ReturnDB,_DBArity);
DebugText(_Player,_Endstring);
DB_DBDebug_FoundReturnDB(1);
PROC_DBDebug_DBList_Loop(_Player,_ReturnDB,_DBName,_DBArity,_NewIndex);

QRY
QRY_DBDebug_FactToString((STRING)_ReturnDB)
THEN
SysClear("DB_QRYRTN_DBDebug_FactToString",1);

//1 param - GUID
QRY
QRY_DBDebug_FactToString("DB_DBDebug_1Param_GUID")
AND
DB_DBDebug_1Param_GUID((GUIDSTRING)_GUID)
AND
GUIDToString(_GUID,_Output)
THEN
DB_QRYRTN_DBDebug_FactToString(_Output);
NOT DB_DBDebug_1Param_GUID((GUIDSTRING)_GUID);

//1 param - STRING
QRY
QRY_DBDebug_FactToString("DB_DBDebug_1Param_STRING")
AND
DB_DBDebug_1Param_STRING((STRING)_Output)
THEN
DB_QRYRTN_DBDebug_FactToString(_Output);
NOT DB_DBDebug_1Param_STRING((STRING)_Output);

//1 param - INTEGER
QRY
QRY_DBDebug_FactToString("DB_DBDebug_1Param_INT")
AND
DB_DBDebug_1Param_INT((INTEGER)_Integer)
AND
IntegerToString(_Integer,_Output)
THEN
DB_QRYRTN_DBDebug_FactToString(_Output);
NOT DB_DBDebug_1Param_INT((INTEGER)_Integer);

//2 param - GUID,GUID
QRY
QRY_DBDebug_FactToString("DB_DBDebug_2Param_GUID_GUID")
AND
DB_DBDebug_2Param_GUID_GUID((GUIDSTRING)_GUID,(GUIDSTRING)_GUID2)
AND
GUIDToString(_GUID,_GUIDstring)
AND
GUIDToString(_GUID2,_GUIDstring2)
AND
Concatenate(_GUIDstring," , ",_Substr1)
AND
Concatenate(_Substr1,_GUIDstring2,_Output)
THEN
DB_QRYRTN_DBDebug_FactToString(_Output);
NOT DB_DBDebug_2Param_GUID_GUID((GUIDSTRING)_GUID,(GUIDSTRING)_GUID2);

//2 param - GUID,INT
QRY
QRY_DBDebug_FactToString("DB_DBDebug_2Param_GUID_INT")
AND
DB_DBDebug_2Param_GUID_INT((GUIDSTRING)_GUID,(INTEGER)_Integer)
AND
GUIDToString(_GUID,_GUIDstring)
AND
Concatenate(_GUIDstring," , ",_Substr1)
AND
ConcatenateInteger(_Substr1,_Integer,_Output)
THEN
DB_QRYRTN_DBDebug_FactToString(_Output);
NOT DB_DBDebug_2Param_GUID_INT((GUIDSTRING)_GUID,(INTEGER)_Integer);

//2 param - GUID,STRING
QRY
QRY_DBDebug_FactToString("DB_DBDebug_2Param_GUID_STRING")
AND
DB_DBDebug_2Param_GUID_STRING((GUIDSTRING)_GUID,(STRING)_String)
AND
GUIDToString(_GUID,_GUIDstring)
AND
Concatenate(_GUIDstring," , ''",_Substr1)
AND
Concatenate(_Substr1,_String,_Substr2)
AND
Concatenate(_Substr2,"''",_Output)
THEN
DB_QRYRTN_DBDebug_FactToString(_Output);
NOT DB_DBDebug_2Param_GUID_STRING((GUIDSTRING)_GUID,(STRING)_String);

//2 param - INT,GUID
QRY
QRY_DBDebug_FactToString("DB_DBDebug_2Param_INT_GUID")
AND
DB_DBDebug_2Param_INT_GUID((INTEGER)_Integer,(GUIDSTRING)_GUID)
AND
GUIDToString(_GUID,_GUIDstring)
AND
IntegerToString(_Integer,_Intstring)
AND
Concatenate(_Intstring," , ",_Substr1)
AND
Concatenate(_Substr1,_GUIDstring,_Output)
THEN
DB_QRYRTN_DBDebug_FactToString(_Output);
NOT DB_DBDebug_2Param_INT_GUID((INTEGER)_Integer,(GUIDSTRING)_GUID);

//2 param - INT,INT
QRY
QRY_DBDebug_FactToString("DB_DBDebug_2Param_INT_INT")
AND
DB_DBDebug_2Param_INT_INT((INTEGER)_Integer,(INTEGER)_Integer2)
AND
IntegerToString(_Integer,_Intstring)
AND
IntegerToString(_Integer2,_Intstring2)
AND
Concatenate(_Intstring," , ",_Substr1)
AND
Concatenate(_Substr1,_Intstring2,_Output)
THEN
DB_QRYRTN_DBDebug_FactToString(_Output);
NOT DB_DBDebug_2Param_INT_INT((INTEGER)_Integer,(INTEGER)_Integer2);

//2 param - INT,STRING
QRY
QRY_DBDebug_FactToString("DB_DBDebug_2Param_INT_STRING")
AND
DB_DBDebug_2Param_INT_STRING((INTEGER)_Integer,(STRING)_String)
AND
IntegerToString(_Integer,_Intstring)
AND
Concatenate(_Intstring," , ''",_Substr1)
AND
Concatenate(_Substr1,_String,_Substr2)
AND
Concatenate(_Substr2,"''",_Output)
THEN
DB_QRYRTN_DBDebug_FactToString(_Output);
NOT DB_DBDebug_2Param_INT_STRING((INTEGER)_Integer,(STRING)_String);

//2 param - STRING,GUID
QRY
QRY_DBDebug_FactToString("DB_DBDebug_2Param_STRING_GUID")
AND
DB_DBDebug_2Param_STRING_GUID((STRING)_String,(GUIDSTRING)_GUID)
AND
GUIDToString(_GUID,_GUIDstring)
AND
Concatenate("''",_String,_Substr1)
AND
Concatenate(_Substr1,"'' , ",_Substr2)
AND
Concatenate(_Substr2,_GUIDstring,_Output)
THEN
DB_QRYRTN_DBDebug_FactToString(_Output);
NOT DB_DBDebug_2Param_STRING_GUID((STRING)_String,(GUIDSTRING)_GUID);

//2 param - STRING,INT
QRY
QRY_DBDebug_FactToString("DB_DBDebug_2Param_STRING_INT")
AND
DB_DBDebug_2Param_STRING_INT((STRING)_String,(INTEGER)_Integer)
AND
IntegerToString(_Integer,_Intstring)
AND
Concatenate("''",_String,_Substr1)
AND
Concatenate(_Substr1,"'' , ",_Substr2)
AND
Concatenate(_Substr2,_Intstring,_Output)
THEN
DB_QRYRTN_DBDebug_FactToString(_Output);
NOT DB_DBDebug_2Param_STRING_INT((STRING)_String,(INTEGER)_Integer);

//2 param - STRING,STRING
QRY
QRY_DBDebug_FactToString("DB_DBDebug_2Param_STRING_STRING")
AND
DB_DBDebug_2Param_STRING_STRING((STRING)_String,(STRING)_String2)
AND
Concatenate("''",_String,_Substr1)
AND
Concatenate(_Substr1,"'' , ''",_Substr2)
AND
Concatenate(_Substr2,_String2,_Substr3)
AND
Concatenate(_Substr3,"''",_Output)
THEN
DB_QRYRTN_DBDebug_FactToString(_Output);
NOT DB_DBDebug_2Param_STRING_STRING((STRING)_String,(STRING)_String2);

//3 param - INT,GUID,INT
QRY
QRY_DBDebug_FactToString("DB_DBDebug_3Param_INT_GUID_INT")
AND
DB_DBDebug_3Param_INT_GUID_INT((INTEGER)_Integer,(GUIDSTRING)_GUID,(INTEGER)_Integer2)
AND
GUIDToString(_GUID,_GUIDstring)
AND
IntegerToString(_Integer,_Intstring)
AND
IntegerToString(_Integer2,_Intstring2)
AND
Concatenate(_Intstring," , ",_Substr1)
AND
Concatenate(_Substr1,_GUIDstring,_Substr2)
AND
Concatenate(_Substr2," , ",_Substr3)
AND
Concatenate(_Substr3,_Intstring2,_Output)
THEN
DB_QRYRTN_DBDebug_FactToString(_Output);
NOT DB_DBDebug_3Param_INT_GUID_INT((INTEGER)_Integer,(GUIDSTRING)_GUID,(INTEGER)_Integer2);

//3 param - GUID,GUID,INT
QRY
QRY_DBDebug_FactToString("DB_DBDebug_3Param_GUID_GUID_INT")
AND
DB_DBDebug_3Param_GUID_GUID_INT((GUIDSTRING)_GUID,(GUIDSTRING)_GUID2,(INTEGER)_Integer)
AND
GUIDToString(_GUID,_GUIDstring)
AND
GUIDToString(_GUID2,_GUIDstring2)
AND
IntegerToString(_Integer,_Intstring)
AND
Concatenate(_GUIDstring," , ",_Substr1)
AND
Concatenate(_Substr1,_GUIDstring2,_Substr2)
AND
Concatenate(_Substr2," , ",_Substr3)
AND
Concatenate(_Substr3,_Intstring,_Output)
THEN
DB_QRYRTN_DBDebug_FactToString(_Output);
NOT DB_DBDebug_3Param_GUID_GUID_INT((GUIDSTRING)_GUID,(GUIDSTRING)_GUID2,(INTEGER)_Integer);

//4 param - GUID,INT,GUID,INT
QRY
QRY_DBDebug_FactToString("DB_DBDebug_4Param_GUID_INT_GUID_INT")
AND
DB_DBDebug_4Param_GUID_INT_GUID_INT((GUIDSTRING)_GUID,(INTEGER)_Integer,(GUIDSTRING)_GUID2,(INTEGER)_Integer2)
AND
GUIDToString(_GUID,_GUIDstring)
AND
IntegerToString(_Integer,_Intstring)
AND
GUIDToString(_GUID2,_GUIDstring2)
AND
IntegerToString(_Integer2,_Intstring2)
AND
Concatenate(_GUIDstring," , ",_Substr1)
AND
Concatenate(_Substr1,_Intstring,_Substr2)
AND
Concatenate(_Substr2," , ",_Substr3)
AND
Concatenate(_Substr3,_GUIDstring2,_Substr4)
AND
Concatenate(_Substr4," , ",_Substr5)
AND
Concatenate(_Substr5,_Intstring2,_Output)
THEN
DB_QRYRTN_DBDebug_FactToString(_Output);
NOT DB_DBDebug_4Param_GUID_INT_GUID_INT((GUIDSTRING)_GUID,(INTEGER)_Integer,(GUIDSTRING)_GUID2,(INTEGER)_Integer2);

IF
TextEvent("dblist_addReturnDBs")
THEN
DB_DBDebug_ReturnDBs(4,"DB_DBDebug_4Param_GUID_INT_GUID_INT");
//END_REGION

//REGION Level unreachable

PROC
PROC_LevelBecameUnreachable((STRING)_LevelName)
THEN
DB_LevelUnreachable(_LevelName);

IF
LevelGameplayStarted(_LevelName,_)
AND
DB_LevelUnreachable_LevelBlocksLevel(_LevelName,_BlockedLevel)
AND
NOT DB_LevelUnreachable(_BlockedLevel)
THEN
PROC_LevelBecameUnreachable((STRING)_BlockedLevel);

PROC
PROC_LevelBecameUnreachable((STRING)_BlockedLevel)
AND
DB_LevelUnreachable_LevelBlocksLevel(_LevelName,_BlockedLevel)
THEN
NOT DB_LevelUnreachable_LevelBlocksLevel(_LevelName,_BlockedLevel);

//Level definitions should be done in a goal in the mod the levels are in
//For Gustav, see _Gustavs_Little_Helpers

IF
DB_LevelUnreachable(_LevelName)
AND
DB_LevelUnreachable_TrackEntity(_Entity)
AND
GetRegion(_Entity,_LevelName)
AND
NOT QRY_ItemInTeamMagicPocketsOrCampChest(_Entity)
THEN
PROC_EntityBecameUnreachable((GUIDSTRING)_Entity,(STRING)_LevelName);

//Useful for journal
PROC
PROC_EntityBecameUnreachable((GUIDSTRING)_Entity,(STRING)_LevelName)
AND
DB_LevelUnreachable_TrackEntity((GUIDSTRING)_Entity)
THEN
NOT DB_LevelUnreachable_TrackEntity((GUIDSTRING)_Entity);

QRY
QRY_EntityIsCurrentlyUnreachable((GUIDSTRING)_Entity)
AND
Exists(_Entity,0)
THEN
DB_NOOP(1);

QRY
QRY_EntityIsCurrentlyUnreachable((GUIDSTRING)_Entity)
AND
Exists(_Entity,1)
AND
GetRegion(_Entity,_Level)
AND
DB_LevelUnreachable(_Level)
THEN
DB_NOOP(1);

// Useful for cleaning up DBs

// Store level name -> index mapping and use index for storing DB_CleanUpLocalOnUnreachable entries to reduce memory/savegame storage size
PROC
PROC_LevelLoadedOnce((STRING)_Level)
AND
QRY_IncreaseCounter("GLO_LevelNameIndexMap")
AND
DB_GlobalCounter("GLO_LevelNameIndexMap",_Index)
THEN
DB_GLO_LevelNameIndexMap(_Level,_Index);

PROC
PROC_CleanUpLocalOnUnreachable((GUIDSTRING)_Entity)
AND
NOT DB_CleanUpLocalOnUnreachable(_,_Entity)
AND
NOT QRY_IsExistingGlobal(_Entity,1)
AND
DB_CurrentLevel(_Level)
AND
DB_GLO_LevelNameIndexMap(_Level,_Index)
THEN
DB_CleanUpLocalOnUnreachable(_Index,_Entity);

PROC
PROC_LevelBecameUnreachable((STRING)_Level)
AND
DB_GLO_LevelNameIndexMap(_Level,_Index)
AND
DB_CleanUpLocalOnUnreachable(_Index,_Entity)
AND
// Handle picked up entities
QRY_EntityIsCurrentlyUnreachable(_Entity)
THEN
PROC_LocalBecameUnreachable(_Entity);

PROC
PROC_LevelBecameUnreachable((STRING)_Level)
AND
DB_GLO_LevelNameIndexMap(_Level,_LevelIndex)
AND
DB_CleanUpLocalOnUnreachable(_LevelIndex,_Entity)
THEN
NOT DB_CleanUpLocalOnUnreachable(_LevelIndex,_Entity);

PROC
PROC_LocalBecameUnreachable((GUIDSTRING)_Entity)
THEN
DB_NOOP(1);

IF
TextEvent("levelunreachable")
AND
GetTextEventParamString(1,_LevelName)
THEN
PROC_LevelBecameUnreachable((STRING)_LevelName);

//END_REGION

//REGION Countdown after long rest
PROC
PROC_LongRest()
AND
DB_LongRestCountDown(_Nights,_GlobalFlag)
AND
IntegerSubtract(_Nights,1,_NewNights)
THEN
DB_LongRestCountDown((INTEGER)_NewNights,(FLAG)_GlobalFlag);

IF
DB_LongRestCountDown(_New,_Flag)
AND
DB_LongRestCountDown(_Old,_Flag)
AND
_New != _Old
THEN
NOT DB_LongRestCountDown((INTEGER)_Old,(FLAG)_Flag);

IF
DB_LongRestCountDown(0,_GlobalFlag)
THEN
NOT DB_LongRestCountDown(0,(FLAG)_GlobalFlag);
SetFlag(_GlobalFlag,NULL_00000000-0000-0000-0000-000000000000,0);
//END_REGION

//REGION Can character perform any action in or outside combat?
//DB_CantAct is not the equivalent to this as it also includes characters in combat
QRY
QRY_IsCharaterUnconsciousOrEquivalent((CHARACTER)_Player)
AND
NOT DB_Dead(_Player)
AND
DB_StatusGroups_UnconsciousOrEquivalent(_StatusGroup)
AND
HasAppliedStatusWithGroup((GUIDSTRING)_Player, _StatusGroup, 1)
THEN
DB_NOOP(1);

QRY
QRY_IsStatusUnconsciousOrEquivalent((STRING)_Status)
AND
DB_StatusGroups_UnconsciousOrEquivalent(_StatusGroup)
AND
IsStatusFromGroup(_Status,_StatusGroup,1)
THEN
DB_NOOP(1);
//END_REGION

//REGION Peacefully Resolve Character
PROC
PROC_PeacefulResolve((CHARACTER)_Character)
AND
NOT DB_PermaDefeated(_Character)
AND
DB_Players(_Player)
AND
NOT DB_PeacefullyResolved(_Character)
THEN
DB_PeacefullyResolved(_Character);
ApplyStatus(_Character, "PEACEFUL_RESOLUTION_XP", -1.0, 1, _Player);

IF
StatusRemoved(_Character, "PEACEFUL_RESOLUTION_XP", _, _)
AND
DB_PeacefullyResolved((CHARACTER)_Character)
THEN
NOT DB_PeacefullyResolved(_Character);
//END_REGION

//REGION Solo Avatar
QRY
QRY_IsSoloAvatar((CHARACTER)_Player)
AND
DB_Avatars(_Player)
AND
DB_GlobalFlag((FLAG)GEN_SoloPlayer_29e32f83-2001-0dbc-7df9-3ca2b3bc4349)
THEN
DB_NOOP(1);
//END_REGION

//REGION Companion has a single attached Avatar
QRY
QRY_CompanionHasSingleAttachedAvatar((CHARACTER)_Companion)
AND
NOT DB_Avatars(_Companion)
AND
DB_Players(_Companion)
AND
DB_Avatars(_Avatar)
AND
QRY_SameUser(_Companion, _Avatar)
AND
NOT QRY_CompanionHasSingleAttachedAvatar_MoreAvatarsAttached(_Companion, _Avatar)
THEN
DB_NOOP(1);

QRY
QRY_CompanionHasSingleAttachedAvatar_MoreAvatarsAttached((CHARACTER)_Companion, (CHARACTER)_Avatar)
AND
DB_Avatars(_OtherAvatar)
AND
_Avatar != _OtherAvatar
AND
QRY_SameUser(_Companion, _OtherAvatar)
THEN
DB_NOOP(1);

//END_REGION

//REGION Making player active
QRY
QRY_MakePlayerActive((CHARACTER)_Player)
THEN
MakePlayerActive(_Player);
//END_REGION

//REGION Set attitude to party if lower
//Sets attiude to the party to a certain number if it is lower
PROC
PROC_RestoreAttitudeToPartyIfLower((CHARACTER)_Character, (INTEGER)_Amount)
AND
DB_PartOfTheTeam(_Player)
AND
_Character != _Player
AND
GetAttitudeTowardsPlayer((CHARACTER)_Character, _Player, _Attitude)
AND
_Attitude < _Amount
THEN
PROC_SetAttitude((CHARACTER)_Character, _Player, _Amount);
//END_REGION

//REGION Round integer number
QRY
QRY_IntegerRoundTo((INTEGER)_Value,(INTEGER)_MultipleOf)
AND
DB_QRYRTN_IntegerRoundTo(_Result)
THEN
NOT DB_QRYRTN_IntegerRoundTo(_Result);

QRY
QRY_IntegerRoundTo((INTEGER)_Value,(INTEGER)_MultipleOf)
AND
IntegerSum(_Value,_MultipleOf,_ValueUpperPlusOne)
AND
IntegerSubtract(_ValueUpperPlusOne,1,_ValueUpper)
AND
IntegerModulo(_ValueUpper,_MultipleOf,_Remainder)
AND
IntegerSubtract(_ValueUpper,_Remainder,_Result)
THEN
DB_QRYRTN_IntegerRoundTo(_Result);

//END_REGION

//REGION Execute in level

//Set up/define with DB_ExecuteInLevel((STRING)_Identifier,(STRING)_Level)
//React to PROC_ExecuteInLevel((STRING)_Identifier,(STRING)_Level)
IF
DB_ExecuteInLevel((STRING)_Identifier,(STRING)_Level)
AND
DB_LevelUnreachable(_Level)
THEN
NOT DB_ExecuteInLevel(_Identifier,_Level);

IF
DB_ExecuteInLevel((STRING)_Identifier,(STRING)_Level)
AND
DB_CurrentLevel(_Level)
THEN
PROC_ExecuteInLevel(_Identifier,_Level);
NOT DB_ExecuteInLevel(_Identifier,_Level);

PROC
PROC_ExecuteInLevel((STRING)_Identifier,(STRING)_Level)
THEN
DB_NOOP(1);

//Set up/define with DB_ExecuteWhenObjectInCurrentLevel((STRING)_Identifier,(GUIDSTRING)_Object)
//React to PROC_ExecuteWhenObjectInCurrentLevel((STRING)_Identifier,(GUIDSTRING)_Object)
IF
DB_ExecuteWhenObjectInCurrentLevel((STRING)_Identifier,(GUIDSTRING)NULL_00000000-0000-0000-0000-000000000000)
THEN
NOT DB_ExecuteWhenObjectInCurrentLevel((STRING)_Identifier,(GUIDSTRING)NULL_00000000-0000-0000-0000-000000000000);

IF
DB_ExecuteWhenObjectInCurrentLevel((STRING)_Identifier,(GUIDSTRING)_Object)
AND
DB_ActiveLevel(_Level)
AND
Exists(_Object,1)
AND
GetRegion(_Object,_Level)
THEN
PROC_ExecuteWhenObjectInCurrentLevel((STRING)_Identifier,(GUIDSTRING)_Object);
NOT DB_ExecuteWhenObjectInCurrentLevel((STRING)_Identifier,(GUIDSTRING)_Object);

IF
EnteredLevel(_Object,_,_Level)
AND
DB_ExecuteWhenObjectInCurrentLevel((STRING)_Identifier,(GUIDSTRING)_Object)
AND
DB_CurrentLevel(_Level)
THEN
PROC_ExecuteWhenObjectInCurrentLevel((STRING)_Identifier,(GUIDSTRING)_Object);
NOT DB_ExecuteWhenObjectInCurrentLevel((STRING)_Identifier,(GUIDSTRING)_Object);

PROC
PROC_ExecuteWhenObjectInCurrentLevel("GLO_OnStage",(GUIDSTRING)_Object)
THEN
SetOnStage(_Object, 1);

PROC
PROC_ExecuteWhenObjectInCurrentLevel("GLO_OffStage",(GUIDSTRING)_Object)
THEN
SetOnStage(_Object, 0);

//END_REGION

//REGION Long Rest helpers

//Helpers for scripters reacting to long resting
//React to PROC_LongRest_InLevel((STRING)_CurrentLevel)
PROC
PROC_LongRest()
AND
DB_CurrentLevel(_Level)
THEN
PROC_LongRest_InLevel(_Level);

//PROC_LongRestOrLevelUnloading((STRING)_Level)
PROC
PROC_LongRest_InLevel((STRING)_Level)
THEN
PROC_LongRestOrLevelUnloading(_Level);

PROC
PROC_LevelUnloading((STRING)_Level)
THEN
PROC_LongRestOrLevelUnloading(_Level);

PROC
PROC_LongRestOrLevelUnloading((STRING)_Level)
THEN
DB_NOOP(1);

//Set up/define with DB_ExecuteInLevel_AfterLongRest((STRING)_Identifier,(STRING)_Level)
//React to PROC_ExecuteInLevel((STRING)_Identifier,(STRING)_Level)
IF
DB_ExecuteInLevel_AfterLongRest((STRING)_Identifier,(STRING)_Level)
AND
DB_LevelUnreachable(_Level)
THEN
NOT DB_ExecuteInLevel_AfterLongRest(_Identifier,_Level);

PROC
PROC_LongRest()
AND
DB_ExecuteInLevel_AfterLongRest((STRING)_Identifier,(STRING)_Level)
THEN
NOT DB_ExecuteInLevel_AfterLongRest(_Identifier,_Level);
DB_ExecuteInLevel((STRING)_Identifier,(STRING)_Level);

PROC
PROC_ExecuteInLevel((STRING)_Identifier,(STRING)_Level)
THEN
DB_NOOP(1);

//END_REGION

//REGION Any Active level

QRY
QRY_AnyActiveLevel()
AND
DB_ActiveLevel(_)
THEN
DB_NOOP(1);


//END_REGION

//REGION Party Item Possession
//Checks if the party possesses an item, regardless of whether it's on their inventory, camp chest or other container in camp, or on the ground in camp

//Is in party inventory, regardless of locked inventories
QRY
QRY_ItemInPartyPosession((ITEM)_Item)
AND
QRY_OnlyOnce_Reset("GLO_Item_CheckPartyPossession")
AND
DB_Players(_Player)
AND
ItemIsInPartyInventory(_Item, _Player, 0, 1)
AND
QRY_OnlyOnce("GLO_Item_CheckPartyPossession")
THEN
DB_NOOP(1);

//Is anywhere in camp that will be picked up by the Decluttering logic. If it is outside of this and would be lost on level transition/switching camps, it will return false.
QRY
QRY_ItemInPartyPosession((ITEM)_Item)
AND
QRY_ItemInCamp(_Item)
THEN
DB_NOOP(1);

//If it's in the active camp
QRY
QRY_ItemInCamp((ITEM)_Item)
AND
DB_ActiveCamp(_ActiveCamp)
AND
DB_Camp(_ActiveCamp, _, _CampArea, _)
AND
IsInTrigger(_Item, _CampArea, 1)
THEN
DB_NOOP(1);

//If it's in the main camp - separate check since Main camp does not get decluttered until players leave the level
QRY
QRY_ItemInCamp((ITEM)_Item)
AND
DB_CurrentLevel(_Level)
AND
DB_MainCamp(_Level, _MainCamp)
AND
NOT DB_ActiveCamp(_MainCamp)
AND
DB_Camp(_MainCamp, _, _CampArea, _)
AND
IsInTrigger(_Item, _CampArea, 1)
THEN
DB_NOOP(1);
//END_REGION

//REGION Block specific characters from selling specific items or templates
IF
DB_CharacterBlockedFromSellingItem(_Character, _Item)
AND
NOT QRY_CharacterBlockedFromSellingItem_CancelledByFlagAlreadySet(_Character, _Item)
THEN
DB_CharacterBlockedFromSellingItem_Active((CHARACTER)_Character, (ITEM)_Item);

IF
DB_CharacterBlockedFromSellingTemplate((CHARACTER)_Character, (ITEMROOT)_Template)
AND
NOT QRY_CharacterBlockedFromSellingTemplate_CancelledByFlagAlreadySet(_Character, _Template)
THEN
DB_CharacterBlockedFromSellingTemplate_Active((CHARACTER)_Character, (ITEMROOT)_Template);

QRY
QRY_CharacterBlockedFromSellingItem_CancelledByFlagAlreadySet((CHARACTER)_Character, (ITEM)_Item)
AND
DB_CharacterBlockedFromSellingItem_CancelledBy(_Character, _Item, _Flag)
AND
DB_GlobalFlag(_Flag)
THEN
NOT DB_CharacterBlockedFromSellingItem(_Character, _Item);
PROC_CharacterBlockedFromSellingItem_PrintErrorMessage(_Character, _Item, _Flag);

QRY
QRY_CharacterBlockedFromSellingTemplate_CancelledByFlagAlreadySet((CHARACTER) _Character, (ITEMROOT)_Template)
AND
DB_CharacterBlockedFromSellingTemplate_CancelledBy(_Character, _Template, _Flag)
AND
DB_GlobalFlag(_Flag)
THEN
NOT DB_CharacterBlockedFromSellingTemplate(_Character, _Template);
PROC_CharacterBlockedFromSellingTemplate_PrintErrorMessage(_Character, _Template, _Flag);

PROC
PROC_CharacterBlockedFromSellingItem_PrintErrorMessage((CHARACTER)_Character, (ITEM)_Item, (FLAG)_Flag)
AND
GUIDToString(_Character, _CharString)
AND
GUIDToString(_Item, _ItemString)
AND
GetFlagName(_Flag, _FlagString)
AND
Concatenate("Scripting Error: Trying to set DB_CharacterBlockedFromSellingItem on character: ", _CharString, _String1)
AND
Concatenate(_String1, " for item: ", _String2)
AND
Concatenate(_String2, _ItemString, _String3)
AND
Concatenate(_String3, " while the CancelledByFlag: ", _String4)
AND
Concatenate(_String4, _FlagString, _String5)
AND
Concatenate(_String5, " is already set. Clearing DB - character will not be blocked from selling. Check if this is correct.", _FinalString)
THEN
DebugBreak(_FinalString);

PROC
PROC_CharacterBlockedFromSellingTemplate_PrintErrorMessage((CHARACTER)_Character, (ITEMROOT)_Template, (FLAG)_Flag)
AND
GUIDToString(_Character, _CharString)
AND
GUIDToString(_Template, _TemplateString)
AND
GetFlagName(_Flag, _FlagString)
AND
Concatenate("Scripting Error: Trying to set DB_CharacterBlockedFromSellingTemplate on character: ", _CharString, _String1)
AND
Concatenate(_String1, " for template: ", _String2)
AND
Concatenate(_String2, _TemplateString, _String3)
AND
Concatenate(_String3, " while the CancelledByFlag: ", _String4)
AND
Concatenate(_String4, _FlagString, _String5)
AND
Concatenate(_String5, " is already set. Clearing DB - character will not be blocked from selling. Check if this is correct.", _FinalString)
THEN
DebugBreak(_FinalString);

//Main logic
// -- Items
IF
AddedTo(_Item, _Character, _)
AND
DB_CharacterBlockedFromSellingItem_Active((CHARACTER)_Character, (ITEM)_Item)
THEN
SetIsTradable(_Item, TRADABLETYPE.NonTradable);

IF
DB_CharacterBlockedFromSellingItem_Active((CHARACTER)_Character, (ITEM)_Item)
AND
IsInInventoryOf(_Item, _Character, 1)
THEN
SetIsTradable(_Item, TRADABLETYPE.NonTradable);

IF
RemovedFrom(_Item, _Character)
AND
DB_CharacterBlockedFromSellingItem_Active((CHARACTER)_Character, (ITEM)_Item)
THEN
SetIsTradable(_Item, TRADABLETYPE.Default);

// -- Templates
IF
TemplateAddedTo(_Template, _Item, _Character, _)
AND
DB_CharacterBlockedFromSellingTemplate_Active((CHARACTER)_Character, (ITEMROOT)_Template)
THEN
SetIsTradable(_Item, TRADABLETYPE.NonTradable);

IF
DB_CharacterBlockedFromSellingTemplate_Active((CHARACTER)_Character, (ITEMROOT)_Template)
THEN
IterateInventoryByTemplate(_Character, _Template, "GLO_CharacterBlockedFromSellingTemplate_SetNonTradeable", "");

IF
EntityEvent(_Item, "GLO_CharacterBlockedFromSellingTemplate_SetNonTradeable")
THEN
SetIsTradable(_Item, TRADABLETYPE.NonTradable);

IF
TemplateRemovedFrom(_Template, _Item, _Character)
AND
DB_CharacterBlockedFromSellingTemplate_Active((CHARACTER)_Character, (ITEMROOT)_Template)
THEN
SetIsTradable(_Item, TRADABLETYPE.Default);

//Cancelling the logic
IF
FlagSet(_Flag, _, _)
AND
DB_CharacterBlockedFromSellingItem_CancelledBy(_Character, _Item, _Flag)
THEN
NOT DB_CharacterBlockedFromSellingItem(_Character, _Item);

IF
DB_CharacterBlockedFromSellingItem_Active(_Character, _Item)
AND
NOT DB_CharacterBlockedFromSellingItem(_Character, _Item)
THEN
NOT DB_CharacterBlockedFromSellingItem_Active(_Character, _Item);
PROC_CharacterBlockedFromSellingItem_CleanUp(_Character, _Item);

PROC
PROC_CharacterBlockedFromSellingItem_CleanUp((CHARACTER)_Character, (ITEM)_Item)
AND
IsInInventoryOf(_Item, _Character, 1)
THEN
SetIsTradable(_Item, TRADABLETYPE.Default);

IF
FlagSet(_Flag, _, _)
AND
DB_CharacterBlockedFromSellingTemplate_CancelledBy(_Character, _Template, _Flag)
THEN
NOT DB_CharacterBlockedFromSellingTemplate(_Character, _Template);

IF
DB_CharacterBlockedFromSellingTemplate_Active(_Character, _Template)
AND
NOT DB_CharacterBlockedFromSellingTemplate(_Character, _Template)
THEN
NOT DB_CharacterBlockedFromSellingTemplate_Active(_Character, _Template);
IterateInventoryByTemplate(_Character, _Template, "GLO_CharacterBlockedFromSellingTemplate_RestoreItemState", "");

IF
EntityEvent(_Item, "GLO_CharacterBlockedFromSellingTemplate_RestoreItemState")
THEN
SetIsTradable(_Item, TRADABLETYPE.Default);
//END_REGION

//REGION Safe object checks and events

QRY
QRY_IsExistingCharacter((GUIDSTRING)_Object,(INTEGER)_IsCharacter)
AND
Exists(_Object,1)
AND
IsCharacter(_Object,_IsCharacter)
THEN
DB_NOOP(1);

QRY
QRY_IsExistingItem((GUIDSTRING)_Object,(INTEGER)_IsItem)
AND
Exists(_Object,1)
AND
IsItem(_Object,_IsItem)
THEN
DB_NOOP(1);

QRY
QRY_IsExistingSummon((GUIDSTRING)_Object,(INTEGER)_IsSummon)
AND
Exists(_Object,1)
AND
IsSummon(_Object,_IsSummon)
THEN
DB_NOOP(1);

QRY
QRY_IsExistingGlobal((GUIDSTRING)_Object,(INTEGER)_IsGlobal)
AND
Exists(_Object,1)
AND
IsGlobal(_Object, _IsGlobal)
THEN
DB_NOOP(1);

//END_REGION

//REGION Safe trigger registering

PROC
PROC_TriggerUnregisterForItemsWhenInLevel((TRIGGER)_Trigger,(STRING)_Level)
AND
_Trigger != NULL_00000000-0000-0000-0000-000000000000
AND
NOT DB_LevelUnreachable(_Level)
THEN
DB_ExecuteWhenObjectInCurrentLevel("TriggerUnregisterForItems", _Trigger);

PROC
PROC_TriggerUnregisterForItemsWhenInLevel((TRIGGER)_Trigger)
AND
_Trigger != NULL_00000000-0000-0000-0000-000000000000
THEN
DB_ExecuteWhenObjectInCurrentLevel("TriggerUnregisterForItems", _Trigger);

PROC
PROC_ExecuteWhenObjectInCurrentLevel("TriggerUnregisterForItems", _Trigger)
THEN
TriggerUnregisterForItems((TRIGGER)_Trigger);

PROC
PROC_TriggerUnregisterForItemsWhenInLevel((TRIGGER)_Trigger)
AND
_Trigger != NULL_00000000-0000-0000-0000-000000000000
THEN
PROC_UnregisterLevelObject("ItemTriggers", _Trigger);

PROC
PROC_LevelObjectUnregistered("ItemTriggers", _Trigger)
THEN
TriggerUnregisterForItems((TRIGGER)_Trigger);

//END_REGION Safe trigger registering

//REGION Inventory + off-staging helpers

//To inventory and on stage
PROC
PROC_ToInventoryAndOnStage((GUIDSTRING)_Object,(GUIDSTRING)_Target)
THEN
PROC_ToInventoryAndOnStage((GUIDSTRING)_Object,(GUIDSTRING)_Target,1,0,0);

PROC
PROC_ToInventoryAndOnStage((GUIDSTRING)_Object,(GUIDSTRING)_Target,(INTEGER)_Amount)
THEN
PROC_ToInventoryAndOnStage((GUIDSTRING)_Object,(GUIDSTRING)_Target,(INTEGER)_Amount,0,0);

PROC
PROC_ToInventoryAndOnStage((GUIDSTRING)_Object,(GUIDSTRING)_Target,(INTEGER)_Amount,(INTEGER)_ShowNotification,(INTEGER)_ClearOriginalOwner)
AND
IsOnStage(_Object,1)
THEN
ToInventory((GUIDSTRING)_Object,(GUIDSTRING)_Target,(INTEGER)_Amount,(INTEGER)_ShowNotification,(INTEGER)_ClearOriginalOwner);

PROC
PROC_ToInventoryAndOnStage((GUIDSTRING)_Object,(GUIDSTRING)_Target,(INTEGER)_Amount,(INTEGER)_ShowNotification,(INTEGER)_ClearOriginalOwner)
AND
IsOnStage(_Object,0)
THEN
PROC_SetOnStage(_Object,1);
DB_ToInventoryAndOnStage((GUIDSTRING)_Object,(GUIDSTRING)_Target,(INTEGER)_Amount,(INTEGER)_ShowNotification,(INTEGER)_ClearOriginalOwner);

IF
WentOnStage((GUIDSTRING)_Object,1)
AND
DB_ToInventoryAndOnStage((GUIDSTRING)_Object,(GUIDSTRING)_Target,(INTEGER)_Amount,(INTEGER)_ShowNotification,(INTEGER)_ClearOriginalOwner)
THEN
ToInventory((GUIDSTRING)_Object,(GUIDSTRING)_Target,(INTEGER)_Amount,(INTEGER)_ShowNotification,(INTEGER)_ClearOriginalOwner);
NOT DB_ToInventoryAndOnStage((GUIDSTRING)_Object,(GUIDSTRING)_Target,(INTEGER)_Amount,(INTEGER)_ShowNotification,(INTEGER)_ClearOriginalOwner);

//Teleport out of inventory and offstage
PROC
PROC_TeleportToAndOffStage((GUIDSTRING)_SourceObject,(GUIDSTRING)_TargetObject)
THEN
PROC_TeleportToAndOffStage((GUIDSTRING)_SourceObject,(GUIDSTRING)_TargetObject,"",0,0,0,0,1);

PROC
PROC_TeleportToAndOffStage((GUIDSTRING)_SourceObject,(GUIDSTRING)_TargetObject,(STRING)_Event)
THEN
PROC_TeleportToAndOffStage((GUIDSTRING)_SourceObject,(GUIDSTRING)_TargetObject,(STRING)_Event,0,0,0,0,1);

PROC
PROC_TeleportToAndOffStage((GUIDSTRING)_SourceObject,(GUIDSTRING)_TargetObject,(STRING)_Event,(INTEGER)_TeleportedLinkedCharacters,(INTEGER)_TeleportPartyFollowers,(INTEGER)_TeleportSummons)
THEN
PROC_TeleportToAndOffStage((GUIDSTRING)_SourceObject,(GUIDSTRING)_TargetObject,(STRING)_Event,(INTEGER)_TeleportedLinkedCharacters,(INTEGER)_TeleportPartyFollowers,(INTEGER)_TeleportSummons,0,1);

PROC
PROC_TeleportToAndOffStage((GUIDSTRING)_SourceObject,(GUIDSTRING)_TargetObject,(STRING)_Event,(INTEGER)_TeleportedLinkedCharacters,(INTEGER)_TeleportPartyFollowers,(INTEGER)_TeleportSummons,(INTEGER)_LeaveCombat,(INTEGER)_SnapToGround)
AND
IsOnStage(_SourceObject,1)
THEN
DB_TeleportToAndOffStage(_SourceObject);

PROC
PROC_TeleportToAndOffStage((GUIDSTRING)_SourceObject,(GUIDSTRING)_TargetObject,(STRING)_Event,(INTEGER)_TeleportedLinkedCharacters,(INTEGER)_TeleportPartyFollowers,(INTEGER)_TeleportSummons,(INTEGER)_LeaveCombat,(INTEGER)_SnapToGround)
THEN
TeleportTo(_SourceObject,_TargetObject,_Event,_TeleportedLinkedCharacters,_TeleportPartyFollowers,_TeleportSummons,_LeaveCombat,_SnapToGround);

IF
RemovedFrom((GUIDSTRING)_Object,_)
AND
DB_TeleportToAndOffStage((GUIDSTRING)_Object)
THEN
PROC_SetOnStage(_Object,0);
NOT DB_TeleportToAndOffStage((GUIDSTRING)_Object);

IF
Teleported((CHARACTER)_Object,_,_,_,_,_,_,_,_)
AND
QRY_IsExistingCharacter(_Object,1)
AND
DB_TeleportToAndOffStage((GUIDSTRING)_Object)
THEN
PROC_SetOnStage(_Object,0);
NOT DB_TeleportToAndOffStage((GUIDSTRING)_Object);

IF
ItemTeleported((ITEM)_Object,_,_,_,_,_,_)
AND
QRY_IsExistingItem(_Object,1)
AND
DB_TeleportToAndOffStage((GUIDSTRING)_Object)
THEN
PROC_SetOnStage(_Object,0);
NOT DB_TeleportToAndOffStage((GUIDSTRING)_Object);

//Teleport to position out of inventory and offstage
PROC
PROC_TeleportToPositionAndOffStage((GUIDSTRING)_SourceObject,(REAL)_X,(REAL)_Y,(REAL)_Z)
THEN
PROC_TeleportToPositionAndOffStage((GUIDSTRING)_SourceObject,(REAL)_X,(REAL)_Y,(REAL)_Z,"",0,0,0,0,1);

PROC
PROC_TeleportToPositionAndOffStage((GUIDSTRING)_SourceObject,(REAL)_X,(REAL)_Y,(REAL)_Z,(STRING)_Event)
THEN
PROC_TeleportToPositionAndOffStage((GUIDSTRING)_SourceObject,(REAL)_X,(REAL)_Y,(REAL)_Z,(STRING)_Event,0,0,0,0,1);

PROC
PROC_TeleportToPositionAndOffStage((GUIDSTRING)_SourceObject,(REAL)_X,(REAL)_Y,(REAL)_Z,(STRING)_Event,(INTEGER)_TeleportedLinkedCharacters,(INTEGER)_TeleportPartyFollowers,(INTEGER)_TeleportSummons)
THEN
PROC_TeleportToPositionAndOffStage((GUIDSTRING)_SourceObject,(REAL)_X,(REAL)_Y,(REAL)_Z,(STRING)_Event,(INTEGER)_TeleportedLinkedCharacters,(INTEGER)_TeleportPartyFollowers,(INTEGER)_TeleportSummons,0,1);

PROC
PROC_TeleportToPositionAndOffStage((GUIDSTRING)_SourceObject,(REAL)_X,(REAL)_Y,(REAL)_Z,(STRING)_Event,(INTEGER)_TeleportedLinkedCharacters,(INTEGER)_TeleportPartyFollowers,(INTEGER)_TeleportSummons,(INTEGER)_LeaveCombat,(INTEGER)_SnapToGround)
AND
IsOnStage(_SourceObject,1)
THEN
DB_TeleportToAndOffStage(_SourceObject);

PROC
PROC_TeleportToPositionAndOffStage((GUIDSTRING)_SourceObject,(REAL)_X,(REAL)_Y,(REAL)_Z,(STRING)_Event,(INTEGER)_TeleportedLinkedCharacters,(INTEGER)_TeleportPartyFollowers,(INTEGER)_TeleportSummons,(INTEGER)_LeaveCombat,(INTEGER)_SnapToGround)
THEN
TeleportToPosition(_SourceObject,_X,_Y,_Z,_Event,_TeleportedLinkedCharacters,_TeleportPartyFollowers,_TeleportSummons,_LeaveCombat,_SnapToGround);

//END_REGION

//REGION Global Flag Set Or Null
QRY
QRY_GlobalFlagSetOrNull((FLAG)_GlobalFlag)
AND
DB_GlobalFlag(_GlobalFlag)
THEN
DB_NOOP(1);

QRY
QRY_GlobalFlagSetOrNull((FLAG)NULL_00000000-0000-0000-0000-000000000000)
THEN
DB_NOOP(1);
//END_REGION
EXITSECTION

ENDEXITSECTION
